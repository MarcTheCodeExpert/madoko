module interface compat
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core/hnd = std/core/hnd = "";
import std/core = std/core = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// The `:io` effect is used for functions that perform arbitrary I/O operations.
local alias std/core/io :: E = <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,((std/core/io-noexn :: E) == 3 <(std/core/types/div :: X),((std/core/io-total :: E) == 2 <(std/core/types/ndet :: X),(std/core/console :: X),(std/core/net :: X),(std/core/fsys :: X),(std/core/ui :: X),((std/core/types/st :: H -> E)<(std/core/types/global :: H)> == 1 <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>>)>)>)> = 4;
 
//------------------------------
//#kki: type declarations
 
 
//------------------------------
//#kki: declarations
 
/*
  Operator "+" --> addition of 2 strings
*/
pub fun (+) : (left : std/core/types/string, right : std/core/types/string) -> std/core/types/string;
/*
  Operator "+" --> addition of 2 list<string>
*/
pub fun (+.1) : forall<a> (left : (std/core/list :: V -> V)<a>, right : (std/core/list :: V -> V)<a>) -> (std/core/list :: V -> V)<a>;
/*
  returns the length of a string
*/
pub fun length : (s : std/core/types/string) -> std/core/types/int;
/*
  from core.kk
*/
fun makeString : (n : std/core/types/int, c : std/core/types/char) -> std/core/types/string;
// Catch an exception raised by "error" and handle it.
// Use "onExn" or "onFail" when appropiate.
pub fun catch_old : forall<(e :: E),a> (action : () -> <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>|(e :: E)> a, hndl : (std/core/exception) -> (e :: E) a) -> (e :: E) a;
// Does string `s`  contain the character `c`  ?
pub fun contains : (s : std/core/types/string, c : std/core/types/char) -> std/core/types/bool;
// monadic lift
fun .mlift2812-dropWhile : forall<a,(e :: E)> (.y.2761 : ((std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<a>)) -> (e :: E) (std/core/list :: V -> V)<a>;
fun dropWhile : forall<a,(e :: E)> (xs : (std/core/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/list :: V -> V)<a>;
/*
  endsWith function from core.kk
*/
pub fun endsWith : (s : std/core/types/string, post : std/core/types/string) -> std/core/types/bool;
// Raise an exception with a specified message.
pub fun error : forall<a> (std/core/types/string) -> <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>> a;
// Returns "true" if the integer `i`  is an even number.
pub fun even : (i : std/core/types/int) -> std/core/types/bool;
/*
  Return the extension (including the `.`)  
  `extname("foo.ext") == ".ext"`, `extname("bla.") == "."`, `extname("bla") == ""` 
  from path.kk
*/
pub fun extname : (p : std/core/types/string) -> std/core/types/string;
pub fun floor : (d : std/core/types/float64) -> std/core/types/float64;
// Fold a list from the right, i.e. `foldr([1,2],0,(+)) == 1+(2+0)` 
// Note, "foldr" is less efficient than "foldl" as it reverses the list first. 
pub fun foldr : forall<a,b,(e :: E)> (xs : (std/core/list :: V -> V)<a>, z : b, f : (a, b) -> (e :: E) b) -> (e :: E) b;
/*
  helper function for showHex from core.kk
*/
fun gformat : forall<a> (value : a, format : std/core/types/string) -> std/core/types/string;
pub fun isNothing : forall<a> (x : (std/core/types/maybe :: V -> V)<a>) -> std/core/types/bool;
fun isWhite : (c : std/core/types/char) -> std/core/types/bool;
// Does string `s`  contain the character `c`  ?
pub fun lastIndexOf : (s : std/core/types/string, c : std/core/types/char) -> std/core/types/int;
// Does string `s`  contain the string `sub`  ?
pub fun lastIndexOf.1 : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/int;
pub val maxInt : std/core/types/int;
val maxListStack : std/core/types/int;
pub fun mbstring : (ms : (std/core/types/maybe :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Compute an md5 hash of a string.
pub fun md5 : (s : std/core/types/string) -> std/core/types/string;
// Returns "true" if the integer `i`  is an odd number.
pub fun odd : (i : std/core/types/int) -> std/core/types/bool;
// Return a default value when an exception is raised
pub fun onExn : forall<a,(e :: E)> (value : a, action : () -> <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>|(e :: E)> a) -> (e :: E) a;
val redirect : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/maybe :: V -> V)<(std/core/types/string) -> <(std/core/console :: X)> ()>>;
pub fun replaceAll : (s : std/core/types/string, pattern : std/core/types/string, repl : std/core/types/string) -> std/core/types/string;
pub fun show : (exn : std/core/exception) -> std/core/types/string;
/*
  startsWith function from core.kk
*/
pub fun startsWith : (s : std/core/types/string, pre : std/core/types/string) -> std/core/types/bool;
pub fun substr2 : (s : std/core/types/string, start : std/core/types/int, len : std/core/types/int) -> std/core/types/string;
/*
  substring functions operating in csharp and js
  all from core.kk
*/
pub fun substr1 : (s : std/core/types/string, start : std/core/types/int) -> std/core/types/string;
/*
  to lowercase funtion from core.kk
*/
pub fun toLower : (s : std/core/types/string) -> std/core/types/string;
// Trim the starting white space of a string 
pub fun trimLeft : (s : std/core/types/string) -> std/core/types/string;
// Trim the ending white space of a string.
pub fun trimRight : (s : std/core/types/string) -> std/core/types/string;
/*
  Construct a string of `n`  characters `c`  (or the empty string if `n <= 0` )
  from core.kk
*/
pub fun string : (n : std/core/types/int, c : std/core/types/char) -> std/core/types/string;
/*
  Right-align a string to width `width`  using `char`  (default is a space) to fill from the left.
  from core.kk
*/
pub fun align : (s : std/core/types/string, width : std/core/types/int, char : (std/core/types/optional :: V -> V)<std/core/types/char>) -> std/core/types/string;
// monadic lift
fun .mlift2813-concat : forall<a,(e :: E)> (.y.2766 : (std/core/list :: V -> V)<(std/core/list :: V -> V)<a>>) -> (e :: E) (std/core/list :: V -> V)<a>;
// Concatenate the result lists from applying a function to all elements
pub fun concat : forall<a,b,(e :: E)> (xs : (std/core/list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/list :: V -> V)<b>) -> (e :: E) (std/core/list :: V -> V)<b>;
pub fun fill : (s : std/core/types/string, width : std/core/types/int, char : (std/core/types/optional :: V -> V)<std/core/types/char>) -> std/core/types/string;
// monadic lift
fun .mlift2814-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(std/core/list :: V -> V)<b>>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (std/core/list :: V -> V)<a>, .y.2767 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/list :: V -> V)<b>;
// monadic lift
fun .mlift2815-op : forall<a,b,(e :: E)> (.accm : ((std/core/list :: V -> V)<b>) -> (std/core/list :: V -> V)<b>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (std/core/list :: V -> V)<a>, .y.2772 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/list :: V -> V)<b>;
pub fun .ctail-filterMap : forall<a,b,(e :: E)> (xs : (std/core/list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .acc : (std/core/types/ctail :: V -> V)<(std/core/list :: V -> V)<b>>) -> (e :: E) (std/core/list :: V -> V)<b>;
pub fun .ctailm-filterMap : forall<a,b,(e :: E)> (xs : (std/core/list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .accm : ((std/core/list :: V -> V)<b>) -> (std/core/list :: V -> V)<b>) -> (e :: E) (std/core/list :: V -> V)<b>;
pub fun filterMap : forall<a,b,(e :: E)> (xs : (std/core/list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/list :: V -> V)<b>;
// monadic lift
fun .mlift2816-foreachUntil : forall<a,b,(e :: E)> (action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (std/core/list :: V -> V)<a>, .y.2780 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// Invoke "action" for each element of a list while "action" return "Nothing"
pub fun foreachUntil : forall<a,b,(e :: E)> (xs : (std/core/list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
fun indexOfAcc : forall<a> (xs : (std/core/list :: V -> V)<a>, pred : (a) -> std/core/types/bool, idx : std/core/types/int) -> std/core/types/int;
// Does string `s`  contain the character `c`  ?
pub fun indexOf : (s : std/core/types/string, c : std/core/types/char) -> std/core/types/int;
// Does string `s`  contain the string `sub`  ?
pub fun indexOf.1 : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/int;
// Returns the index of the first element where "pred" holds, or "-1" if no such element exists.
pub fun indexOf.2 : forall<a> (xs : (std/core/list :: V -> V)<a>, pred : (a) -> std/core/types/bool) -> std/core/types/int;
// Parse digits in a "base" between 2 and 36 (default 10) given an initial value "acc" (default 0)
// Returns "acc" on the empty string, and "Nothing" if an invalid digit is encountered.
fun parseDigits : (cs : (std/core/list :: V -> V)<std/core/types/char>, base : (std/core/types/optional :: V -> V)<std/core/types/int>, acc : (std/core/types/optional :: V -> V)<std/core/types/int>) -> (std/core/types/maybe :: V -> V)<std/core/types/int>;
fun parsePosInt : (s : (std/core/list :: V -> V)<std/core/types/char>, base : (std/core/types/optional :: V -> V)<std/core/types/int>) -> (std/core/types/maybe :: V -> V)<std/core/types/int>;
pub fun parseInt : (s : std/core/types/string, hex : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> (std/core/types/maybe :: V -> V)<std/core/types/int>;
pub fun parseFixed : (s : std/core/types/string) -> (std/core/types/maybe :: V -> V)<std/core/types/float64>;
pub fun parseFixedDefault : (s : std/core/types/string, default : (std/core/types/optional :: V -> V)<std/core/types/float64>) -> std/core/types/float64;
pub fun parseIntDefault : (s : std/core/types/string, default : (std/core/types/optional :: V -> V)<std/core/types/int>, hex : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> std/core/types/int;
pub fun printRedirect : (print : (msg : std/core/types/string) -> <(std/core/console :: X)> ()) -> <(std/core/io :: E)> ();
pub fun show2 : (i : std/core/types/int) -> std/core/types/string;
/*
  showHex function from core.kk
*/
pub fun showHex : (i : std/core/types/int, width : (std/core/types/optional :: V -> V)<std/core/types/int>, useCapitals : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> std/core/types/string;
pub fun substr : (s : std/core/types/string, start : std/core/types/int) -> std/core/types/string;
pub fun substr.1 : (s : std/core/types/string, start : std/core/types/int, len : std/core/types/int) -> std/core/types/string;
// monadic lift
fun .mlift2817-zipWithAcc : forall<(e :: E),a,b,c> (acc : (std/core/list :: V -> V)<b>, f : (std/core/types/int, a, c) -> (e :: E) b, i : std/core/types/int, xx : (std/core/list :: V -> V)<a>, yy : (std/core/list :: V -> V)<c>, .y.2784 : b) -> (e :: E) (std/core/list :: V -> V)<b>;
fun zipWithAcc : forall<a,b,c,(e :: E)> ((std/core/types/int, a, b) -> (e :: E) c, std/core/types/int, (std/core/list :: V -> V)<c>, (std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<b>) -> (e :: E) (std/core/list :: V -> V)<c>;
// monadic lift
fun .mlift2818-op : forall<(e :: E),a> (.acc : (std/core/types/ctail :: V -> V)<(std/core/list :: V -> V)<a>>, .y.2788 : (std/core/list :: V -> V)<a>) -> (e :: E) (std/core/list :: V -> V)<a>;
// monadic lift
fun .mlift2819-op : forall<(e :: E),a,b,c> (.acc : (std/core/types/ctail :: V -> V)<(std/core/list :: V -> V)<c>>, f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xx : (std/core/list :: V -> V)<a>, yy : (std/core/list :: V -> V)<b>, .ctail.2754 : c) -> (e :: E) (std/core/list :: V -> V)<c>;
// monadic lift
fun .mlift2820-op : forall<(e :: E),a,b,c> (.accm : ((std/core/list :: V -> V)<c>) -> (std/core/list :: V -> V)<c>, f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xx : (std/core/list :: V -> V)<a>, yy : (std/core/list :: V -> V)<b>, .ctail.2759 : c) -> (e :: E) (std/core/list :: V -> V)<c>;
pub fun .ctail-zipWithIter : forall<a,b,c,(e :: E)> ((std/core/types/int, a, b) -> (e :: E) c, std/core/types/int, (std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<b>, .acc : (std/core/types/ctail :: V -> V)<(std/core/list :: V -> V)<c>>) -> (e :: E) (std/core/list :: V -> V)<c>;
pub fun .ctailm-zipWithIter : forall<a,b,c,(e :: E)> ((std/core/types/int, a, b) -> (e :: E) c, std/core/types/int, (std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<b>, .accm : ((std/core/list :: V -> V)<c>) -> (std/core/list :: V -> V)<c>) -> (e :: E) (std/core/list :: V -> V)<c>;
pub fun zipWithIter : forall<a,b,c,(e :: E)> ((std/core/types/int, a, b) -> (e :: E) c, std/core/types/int, (std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<b>) -> (e :: E) (std/core/list :: V -> V)<c>;
// Zip two lists together by apply a pub fun "f" to all corresponding elements
// and their index in the list.
// The returned list is only as long as the smallest input list.
pub fun zipWithIndexed : forall<a,b,c,(e :: E)> (xs : (std/core/list :: V -> V)<a>, ys : (std/core/list :: V -> V)<b>, f : (std/core/types/int, a, b) -> (e :: E) c) -> (e :: E) (std/core/list :: V -> V)<c>;
// Zip two lists together by pairing the corresponding elements.
// The returned list is only as long as the smallest input list.
pub fun zip : forall<a,b> (xs : (std/core/list :: V -> V)<a>, ys : (std/core/list :: V -> V)<b>) -> (std/core/list :: V -> V)<(a, b)>;
// Zip two lists together by apply a pub fun "f" to all corresponding elements.
// The returned list is only as long as the smallest input list.
pub fun zipWith : forall<a,b,c,(e :: E)> (xs : (std/core/list :: V -> V)<a>, ys : (std/core/list :: V -> V)<b>, f : (a, b) -> (e :: E) c) -> (e :: E) (std/core/list :: V -> V)<c>;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
specialize "_*" fun concat // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/list :: V -> V)<b>){
    std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xss : (std/core/list :: V -> V)<(std/core/list :: V -> V)<b>>) -> (std/core/list :: V -> V)<b>,(xss : (std/core/list :: V -> V)<(std/core/list :: V -> V)<b>>) -> (e :: E) (std/core/list :: V -> V)<b>>((std/core/concat<b>))((std/core/map.5<a,(std/core/list :: V -> V)<b>,(e :: E)>(xs, f)));
  };
specialize "_*" fun dropWhile // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(((std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<a>)) -> (std/core/list :: V -> V)<a>,(((std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<a>)) -> (e :: E) (std/core/list :: V -> V)<a>>((std/core/types/snd<(std/core/list :: V -> V)<a>,(std/core/list :: V -> V)<a>>))((std/core/span<a,(e :: E)>(xs, predicate)));
  };
recursive specialize "_*" fun filterMap // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, pred: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/Nil() : (std/core/list :: V -> V)<a> ) as .pat: ((std/core/list :: V -> V)<a>))
         -> std/core/Nil<b>;
      ((.skip std/core/Cons((x: a) : a, (xx: (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a> ) as .pat0: ((std/core/list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as .pat1: ((std/core/types/maybe :: V -> V)<b>))
             -> compat/filterMap<a,b,(e :: E)>(xx, pred);
          ((.skip std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as .pat2: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/Cons<b>(y, (compat/filterMap<a,b,(e :: E)>(xx, pred)));
        });
    });
  };
specialize "__*" fun foldr // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, z: b, f: (a, b) -> (e :: E) b){
    std/core/foldl<a,b,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<a>) -> (std/core/list :: V -> V)<a>,(xs : (std/core/list :: V -> V)<a>) -> (e :: E) (std/core/list :: V -> V)<a>>((std/core/reverse<a>))(xs)), z, (fn<(e :: E)>(x: b, y: a){
        (f(y, x));
      }));
  };
recursive specialize "_*" fun foreachUntil // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/Nil() : (std/core/list :: V -> V)<a> ) as .pat: ((std/core/list :: V -> V)<a>))
         -> std/core/types/Nothing<b>;
      ((.skip std/core/Cons((x: a) : a, (xx: (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a> ) as .pat0: ((std/core/list :: V -> V)<a>))
         -> (match ((action(x))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as .pat1: ((std/core/types/maybe :: V -> V)<b>))
             -> compat/foreachUntil<a,b,(e :: E)>(xx, action);
          (res: ((std/core/types/maybe :: V -> V)<b>))
             -> res;
        });
    });
  };
specialize "_*" fun indexOf.2 // inline size: 1
  = forall<a> fn(xs: (std/core/list :: V -> V)<a>, pred: (a) -> std/core/types/bool){
    compat/indexOfAcc<a>(xs, pred, 0);
  };
recursive specialize "_*_" fun indexOfAcc // inline size: 6
  = forall<a> fn(xs: (std/core/list :: V -> V)<a>, pred: (a) -> std/core/types/bool, idx: std/core/types/int){
    (match (xs) {
      ((std/core/Nil() : (std/core/list :: V -> V)<a> ) as .pat: ((std/core/list :: V -> V)<a>))
         -> std/core/int-sub(0, 1);
      ((.skip std/core/Cons((x0: a) : a, (xx: (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a> ) as .pat0: ((std/core/list :: V -> V)<a>))
         -> (match ((pred(x0))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> idx;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> compat/indexOfAcc<a>(xx, pred, (std/core/int-add(idx, 1)));
        });
    });
  };
specialize "__*" fun zipWith // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>, f: (a, b) -> (e :: E) c){
    compat/zipWithIter<a,b,c,(e :: E)>((fn<(e :: E)>(i: std/core/types/int, x: a, y: b){
        (f(x, y));
      }), 0, xs, ys);
  };
recursive specialize "*____" fun zipWithAcc // inline size: 12
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(f: (std/core/types/int, a, b) -> (e :: E) c, i: std/core/types/int, acc: (std/core/list :: V -> V)<c>, xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>){
    (match (xs) {
      ((std/core/Nil() : (std/core/list :: V -> V)<a> ) as .pat: ((std/core/list :: V -> V)<a>))
         -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<c>) -> (std/core/list :: V -> V)<c>,(xs : (std/core/list :: V -> V)<c>) -> (e :: E) (std/core/list :: V -> V)<c>>((std/core/reverse<c>))(acc);
      ((.skip std/core/Cons((x: a) : a, (xx: (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a> ) as .pat0: ((std/core/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/Nil() : (std/core/list :: V -> V)<b> ) as .pat1: ((std/core/list :: V -> V)<b>))
             -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<c>) -> (std/core/list :: V -> V)<c>,(xs : (std/core/list :: V -> V)<c>) -> (e :: E) (std/core/list :: V -> V)<c>>((std/core/reverse<c>))(acc);
          ((.skip std/core/Cons((y: b) : b, (yy: (std/core/list :: V -> V)<b>) : (std/core/list :: V -> V)<b>) : (std/core/list :: V -> V)<b> ) as .pat2: ((std/core/list :: V -> V)<b>))
             -> compat/zipWithAcc<a,b,c,(e :: E)>(f, (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x0: std/core/types/int, y0: std/core/types/int){
                (std/core/int-add(x0, y0));
              }))(i, 1)), (std/core/Cons<c>((f(i, x, y)), acc)), xx, yy);
        });
    });
  };
specialize "__*" fun zipWithIndexed // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>, f: (std/core/types/int, a, b) -> (e :: E) c){
    compat/zipWithIter<a,b,c,(e :: E)>(f, 0, xs, ys);
  };
specialize "*___" fun zipWithIter // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(f: (std/core/types/int, a, b) -> (e :: E) c, i: std/core/types/int, xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/(>.1))(i, 200))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> compat/zipWithAcc<a,b,c,(e :: E)>(f, i, (std/core/Nil<c>), xs, ys);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match (xs) {
          ((std/core/Nil() : (std/core/list :: V -> V)<a> ) as .pat1: ((std/core/list :: V -> V)<a>))
             -> std/core/Nil<c>;
          ((.skip std/core/Cons((x: a) : a, (xx: (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a> ) as .pat2: ((std/core/list :: V -> V)<a>))
             -> (match (ys) {
              ((std/core/Nil() : (std/core/list :: V -> V)<b> ) as .pat3: ((std/core/list :: V -> V)<b>))
                 -> std/core/Nil<c>;
              ((.skip std/core/Cons((y: b) : b, (yy: (std/core/list :: V -> V)<b>) : (std/core/list :: V -> V)<b>) : (std/core/list :: V -> V)<b> ) as .pat4: ((std/core/list :: V -> V)<b>))
                 -> std/core/Cons<c>((f(i, x, y)), (compat/zipWithIter<a,b,c,(e :: E)>(f, (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x0: std/core/types/int, y0: std/core/types/int){
                      (std/core/int-add(x0, y0));
                    }))(i, 1)), xx, yy)));
            });
        });
    });
  };
fun (+) // inline size: 1
  = fn(left: std/core/types/string, right: std/core/types/string){
    std/core/(++.1)(left, right);
  };
fun (+.1) // inline size: 1
  = forall<a> fn(left: (std/core/list :: V -> V)<a>, right: (std/core/list :: V -> V)<a>){
    std/core/append<a>(left, right);
  };
fun length // inline size: 1
  = fn(s: std/core/types/string){
    std/core/count.1(s);
  };
fun dropWhile // inline size: 3
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(((std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<a>)) -> (std/core/list :: V -> V)<a>,(((std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<a>)) -> (e :: E) (std/core/list :: V -> V)<a>>((std/core/types/snd<(std/core/list :: V -> V)<a>,(std/core/list :: V -> V)<a>>))((std/core/span<a,(e :: E)>(xs, predicate)));
  };
fun even // inline size: 2
  = fn(i: std/core/types/int){
    std/core/(==.1)((std/core/(%)(i, 2)), 0);
  };
fun foldr // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, z: b, f: (a, b) -> (e :: E) b){
    std/core/foldl<a,b,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<a>) -> (std/core/list :: V -> V)<a>,(xs : (std/core/list :: V -> V)<a>) -> (e :: E) (std/core/list :: V -> V)<a>>((std/core/reverse<a>))(xs)), z, (fn<(e :: E)>(x: b, y: a){
        (f(y, x));
      }));
  };
fun isNothing // inline size: 1
  = forall<a> fn(x: (std/core/types/maybe :: V -> V)<a>){
    (match (x) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/True;
      (.pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline val maxInt // inline size: 0
  = 2147483647;
inline val maxListStack // inline size: 0
  = 200;
fun mbstring // inline size: 1
  = fn(ms: (std/core/types/maybe :: V -> V)<std/core/types/string>){
    match (ms) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<std/core/types/string> ) as .pat: ((std/core/types/maybe :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/types/Just((s: std/core/types/string) : std/core/types/string) : (std/core/types/maybe :: V -> V)<std/core/types/string> ) as .pat0: ((std/core/types/maybe :: V -> V)<std/core/types/string>))
         -> s;
    };
  };
fun odd // inline size: 2
  = fn(i: std/core/types/int){
    std/core/(!=.1)((std/core/(%)(i, 2)), 0);
  };
fun onExn // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(value: a, action: () -> <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>|(e :: E)> a){
    std/core/try<a,(e :: E)>(action, (fn<(e :: E)>(._wildcard_210_22: std/core/exception){
        value;
      }));
  };
fun string // inline size: 3
  = fn(n: std/core/types/int, c: std/core/types/char){
    match ((std/core/(<=.1)(n, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> "";
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> compat/makeString(n, c);
    };
  };
fun concat // inline size: 3
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/list :: V -> V)<b>){
    std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xss : (std/core/list :: V -> V)<(std/core/list :: V -> V)<b>>) -> (std/core/list :: V -> V)<b>,(xss : (std/core/list :: V -> V)<(std/core/list :: V -> V)<b>>) -> (e :: E) (std/core/list :: V -> V)<b>>((std/core/concat<b>))((std/core/map.5<a,(std/core/list :: V -> V)<b>,(e :: E)>(xs, f)));
  };
fun indexOf.2 // inline size: 1
  = forall<a> fn(xs: (std/core/list :: V -> V)<a>, pred: (a) -> std/core/types/bool){
    compat/indexOfAcc<a>(xs, pred, 0);
  };
fun parseFixedDefault // inline size: 3
  = fn(s: std/core/types/string, default: (std/core/types/optional :: V -> V)<std/core/types/float64>){
    match ((compat/parseFixed(s))) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<std/core/types/float64> ) as .pat1: ((std/core/types/maybe :: V -> V)<std/core/types/float64>))
         -> (match (default) {
          ((std/core/types/Optional((.default.2171: std/core/types/float64) : std/core/types/float64) : (std/core/types/optional :: V -> V)<std/core/types/float64> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/float64>))
             -> .default.2171;
          ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/float64> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/float64>))
             -> 0.0;
        });
      ((.skip std/core/types/Just((d: std/core/types/float64) : std/core/types/float64) : (std/core/types/maybe :: V -> V)<std/core/types/float64> ) as .pat2: ((std/core/types/maybe :: V -> V)<std/core/types/float64>))
         -> d;
    };
  };
fun printRedirect // inline size: 3
  = fn<(std/core/io :: E)>(print: (msg : std/core/types/string) -> <(std/core/console :: X)> ()){
    std/core/types/.open<<(std/core/types/write :: H -> X)<(std/core/types/global :: H)>>,<(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X)>,(ref : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/maybe :: V -> V)<(std/core/types/string) -> <(std/core/console :: X)> ()>>, assigned : (std/core/types/maybe :: V -> V)<(std/core/types/string) -> <(std/core/console :: X)> ()>) -> <(std/core/types/write :: H -> X)<(std/core/types/global :: H)>> (),(ref : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/maybe :: V -> V)<(std/core/types/string) -> <(std/core/console :: X)> ()>>, assigned : (std/core/types/maybe :: V -> V)<(std/core/types/string) -> <(std/core/console :: X)> ()>) -> <(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X)> ()>((std/core/types/set<(std/core/types/maybe :: V -> V)<(std/core/types/string) -> <(std/core/console :: X)> ()>,(std/core/types/global :: H)>))(compat/redirect, (std/core/types/Just<(msg : std/core/types/string) -> <(std/core/console :: X)> ()>(print)));
  };
fun show2 // inline size: 3
  = fn(i: std/core/types/int){
    compat/align((std/core/show(i)), 2, (std/core/types/Optional<std/core/types/char>('0')));
  };
fun substr.1 // inline size: 3
  = fn(s: std/core/types/string, start: std/core/types/int, len: std/core/types/int){
    match ((std/core/(<=.1)(len, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> "";
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> compat/substr2(s, start, len);
    };
  };
fun zipWithIndexed // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>, f: (std/core/types/int, a, b) -> (e :: E) c){
    compat/zipWithIter<a,b,c,(e :: E)>(f, 0, xs, ys);
  };
fun zip // inline size: 2
  = forall<a,b> fn(xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>){
    compat/zipWithIter<a,b,(a, b),(std/core/types/(<>) :: E)>((fn(i: std/core/types/int, x: a, y: b){
        (std/core/types/(,)<a,b>(x, y));
      }), 0, xs, ys);
  };
fun zipWith // inline size: 2
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>, f: (a, b) -> (e :: E) c){
    compat/zipWithIter<a,b,c,(e :: E)>((fn<(e :: E)>(i: std/core/types/int, x: a, y: b){
        (f(x, y));
      }), 0, xs, ys);
  };