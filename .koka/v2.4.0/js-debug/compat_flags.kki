/*
Parsing of command line flags.
*/
module interface compat/flags
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core/hnd = std/core/hnd = "";
import std/core = std/core = "";
import compat = compat = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// An alias for the empty effect.
local alias std/core/total :: E = (std/core/types/(<>) :: E) = 1;
 
//------------------------------
//#kki: type declarations
 
value{0,1} type flagKind <a> :: V -> V {
  con Flg(set: (a) -> a) : forall<a> (set : (a) -> a) -> (flagKind :: V -> V)<a>;
  con Arg(arg: std/core/types/string) : forall<a> (arg : std/core/types/string) -> (flagKind :: V -> V)<a>;
  con End : forall<a> (flagKind :: V -> V)<a>;
  con Unknown(arg: std/core/types/string) : forall<a> (arg : std/core/types/string) -> (flagKind :: V -> V)<a>;
  con Error(msg: std/core/types/string) : forall<a> (msg : std/core/types/string) -> (flagKind :: V -> V)<a>;
};
// Specifies the argument of an option
pub value{0,2} type optionArg <a> :: V -> V {
  // For a flag `foo` Automatically enables forms `--nofoo` and `--foo=true|false`.
  pub con Flag(default: (a, std/core/types/bool) -> a) : forall<a> (default : (a, std/core/types/bool) -> a) -> (optionArg :: V -> V)<a>;
  // A required argument.
  pub con Req(parse: (a, std/core/types/string) -> a, help: std/core/types/string) : forall<a> (parse : (a, std/core/types/string) -> a, help : std/core/types/string) -> (optionArg :: V -> V)<a>;
  // An optional argument.
  pub con Opt(parse: (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, help: std/core/types/string) : forall<a> (parse : (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, help : std/core/types/string) -> (optionArg :: V -> V)<a>;
};
// Specifies a single option
// For example: "Option(""h?"",[""help""],Flag(Help),""show help information"")".
pub type option <a> :: V -> V {
  // Specifies a single option
// For example: "Option(""h?"",[""help""],Flag(Help),""show help information"")".
  pub con Option(shortNames: std/core/types/string, longNames: (std/core/list :: V -> V)<std/core/types/string>, arg: (optionArg :: V -> V)<a>, help: std/core/types/string, llongNames: (std/core/list :: V -> V)<std/core/types/string>) : forall<a> (shortNames : std/core/types/string, longNames : (std/core/list :: V -> V)<std/core/types/string>, arg : (optionArg :: V -> V)<a>, help : std/core/types/string, llongNames : (std/core/list :: V -> V)<std/core/types/string>) -> (option :: V -> V)<a>;
};
// Specifies how to handle options that follow nonOption command line arguments.
pub value{0,1} type optionOrder <a> :: V -> V {
  // Allow options to be permuted with nonFlag arguments
  pub con Permute : forall<a> (optionOrder :: V -> V)<a>;
  // Flags following nonOption arguments are treated as arguments
  pub con Preorder : forall<a> (optionOrder :: V -> V)<a>;
  // Wrap each nonOption argument into an option
  pub con Wrap(wrap: (std/core/types/string) -> a) : forall<a> (wrap : (std/core/types/string) -> a) -> (optionOrder :: V -> V)<a>;
};
type testOptions {
  con TestOptions(verbose: std/core/types/bool, version: std/core/types/bool, name: std/core/types/string, output: std/core/types/string, arguments: (std/core/list :: V -> V)<std/core/types/string>) : (verbose : std/core/types/bool, version : std/core/types/bool, name : std/core/types/string, output : std/core/types/string, arguments : (std/core/list :: V -> V)<std/core/types/string>) -> testOptions;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Tests for the `Flg` constructor of the `:flagKind` type.
fun is-flg : forall<a> (^ flagKind : (flagKind :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Arg` constructor of the `:flagKind` type.
fun is-arg : forall<a> (^ flagKind : (flagKind :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `End` constructor of the `:flagKind` type.
fun is-end : forall<a> (^ flagKind : (flagKind :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Unknown` constructor of the `:flagKind` type.
fun is-unknown : forall<a> (^ flagKind : (flagKind :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Error` constructor of the `:flagKind` type.
fun is-error : forall<a> (^ flagKind : (flagKind :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Flag` constructor of the `:optionArg` type.
pub fun is-flag : forall<a> (^ optionArg : (optionArg :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Req` constructor of the `:optionArg` type.
pub fun is-req : forall<a> (^ optionArg : (optionArg :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Opt` constructor of the `:optionArg` type.
pub fun is-opt : forall<a> (^ optionArg : (optionArg :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Retrieves the `shortNames` constructor field of the `:option` type.
pub fun shortNames : forall<a> (^ option : (option :: V -> V)<a>) -> std/core/types/string;
// Automatically generated. Retrieves the `longNames` constructor field of the `:option` type.
pub fun longNames : forall<a> (^ option : (option :: V -> V)<a>) -> (std/core/list :: V -> V)<std/core/types/string>;
// Automatically generated. Retrieves the `arg` constructor field of the `:option` type.
pub fun arg : forall<a> (^ option : (option :: V -> V)<a>) -> (optionArg :: V -> V)<a>;
// Automatically generated. Retrieves the `help` constructor field of the `:option` type.
pub fun help : forall<a> (^ option : (option :: V -> V)<a>) -> std/core/types/string;
// Automatically generated. Retrieves the `llongNames` constructor field of the `:option` type.
pub fun llongNames : forall<a> (^ option : (option :: V -> V)<a>) -> (std/core/list :: V -> V)<std/core/types/string>;
pub fun .copy : forall<a> (.this : (option :: V -> V)<a>, shortNames : (std/core/types/optional :: V -> V)<std/core/types/string>, longNames : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>, arg : (std/core/types/optional :: V -> V)<(optionArg :: V -> V)<a>>, help : (std/core/types/optional :: V -> V)<std/core/types/string>, llongNames : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>) -> (option :: V -> V)<a>;
// Automatically generated. Tests for the `Permute` constructor of the `:optionOrder` type.
pub fun is-permute : forall<a> (^ optionOrder : (optionOrder :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Preorder` constructor of the `:optionOrder` type.
pub fun is-preorder : forall<a> (^ optionOrder : (optionOrder :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Wrap` constructor of the `:optionOrder` type.
pub fun is-wrap : forall<a> (^ optionOrder : (optionOrder :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Retrieves the `verbose` constructor field of the `:testOptions` type.
fun verbose : (^ testOptions : testOptions) -> std/core/types/bool;
// Automatically generated. Retrieves the `version` constructor field of the `:testOptions` type.
fun version : (^ testOptions : testOptions) -> std/core/types/bool;
// Automatically generated. Retrieves the `name` constructor field of the `:testOptions` type.
fun name : (^ testOptions : testOptions) -> std/core/types/string;
// Automatically generated. Retrieves the `output` constructor field of the `:testOptions` type.
fun output : (^ testOptions : testOptions) -> std/core/types/string;
// Automatically generated. Retrieves the `arguments` constructor field of the `:testOptions` type.
fun arguments : (^ testOptions : testOptions) -> (std/core/list :: V -> V)<std/core/types/string>;
fun .copy.1 : (.this : testOptions, verbose : (std/core/types/optional :: V -> V)<std/core/types/bool>, version : (std/core/types/optional :: V -> V)<std/core/types/bool>, name : (std/core/types/optional :: V -> V)<std/core/types/string>, output : (std/core/types/optional :: V -> V)<std/core/types/string>, arguments : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>) -> testOptions;
fun setName : (t : testOptions, name : std/core/types/string) -> testOptions;
fun setOutput : (t : testOptions, mbs : (std/core/types/maybe :: V -> V)<std/core/types/string>) -> testOptions;
fun setVerbose : (t : testOptions, v : std/core/types/bool) -> testOptions;
fun setVersion : (t : testOptions, v : std/core/types/bool) -> testOptions;
fun break : (s : std/core/types/string, c : std/core/types/char) -> (std/core/types/string, std/core/types/string);
fun showLongArg : forall<a> (arg : (optionArg :: V -> V)<a>) -> std/core/types/string;
fun showShortArg : forall<a> (arg : (optionArg :: V -> V)<a>) -> std/core/types/string;
// lifted local: unzip3, iter
fun .lift7167-unzip3 : forall<a,b,c> (ys : (std/core/list :: V -> V)<(a, b, c)>, acc1 : (std/core/list :: V -> V)<a>, acc2 : (std/core/list :: V -> V)<b>, acc3 : (std/core/list :: V -> V)<c>) -> ((std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<b>, (std/core/list :: V -> V)<c>);
// Unzip a list of triples into three lists
fun unzip3 : forall<a,b,c> (xs : (std/core/list :: V -> V)<(a, b, c)>) -> ((std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<b>, (std/core/list :: V -> V)<c>);
fun errorNegate : forall<a> (flagname : std/core/types/string) -> (flagKind :: V -> V)<a>;
fun errorNoarg : forall<a> (opt : std/core/types/string) -> (flagKind :: V -> V)<a>;
fun errorRequired : forall<a> (help : std/core/types/string, opt : std/core/types/string) -> (flagKind :: V -> V)<a>;
fun errorUnknownMessage : (opt : std/core/types/string) -> std/core/types/string;
fun showOptions : (o : testOptions) -> std/core/types/string;
// Specifies a single option
// For example: "Option(""h?"",[""help""],Flag(Help),""show help information"")".
pub fun .create-Option : forall<a> (shortNames : std/core/types/string, longNames : (std/core/list :: V -> V)<std/core/types/string>, arg : (optionArg :: V -> V)<a>, help : std/core/types/string, llongNames : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>) -> (option :: V -> V)<a>;
val testOptions : (std/core/list :: V -> V)<(option :: V -> V)<testOptions>>;
fun .create-TestOptions : (verbose : (std/core/types/optional :: V -> V)<std/core/types/bool>, version : (std/core/types/optional :: V -> V)<std/core/types/bool>, name : (std/core/types/optional :: V -> V)<std/core/types/string>, output : (std/core/types/optional :: V -> V)<std/core/types/string>, arguments : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>) -> testOptions;
fun showFlag : forall<a> (flag : (option :: V -> V)<a>) -> (std/core/list :: V -> V)<(std/core/types/string, std/core/types/string, std/core/types/string)>;
// monadic lift
fun .mlift7174-zipWith3Acc : forall<(e :: E),a,b,c,d> (acc : (std/core/list :: V -> V)<b>, f : (a, c, d) -> (e :: E) b, xx : (std/core/list :: V -> V)<a>, yy : (std/core/list :: V -> V)<c>, zz : (std/core/list :: V -> V)<d>, .y.7168 : b) -> (e :: E) (std/core/list :: V -> V)<b>;
fun zipWith3Acc : forall<a,b,c,d,(e :: E)> ((a, b, c) -> (e :: E) d, (std/core/list :: V -> V)<d>, (std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<b>, (std/core/list :: V -> V)<c>) -> (e :: E) (std/core/list :: V -> V)<d>;
fun zipWith3 : forall<a,b,c,d,(e :: E)> (f : (a, b, c) -> (e :: E) d, xs : (std/core/list :: V -> V)<a>, ys : (std/core/list :: V -> V)<b>, zs : (std/core/list :: V -> V)<c>) -> (e :: E) (std/core/list :: V -> V)<d>;
// Return a nicely formatted string describing the usage of a command,
// consisting of a "header" followed by the descriptions of the "flags".
pub fun usageInfo : forall<a> (flags : (std/core/list :: V -> V)<(option :: V -> V)<a>>, header : std/core/types/string) -> std/core/types/string;
fun errorAmbiguous : forall<a,b> (applicable : (std/core/list :: V -> V)<(option :: V -> V)<a>>, opt : std/core/types/string) -> (flagKind :: V -> V)<b>;
fun errorUnknown : forall<a> (opt : std/core/types/string) -> (flagKind :: V -> V)<a>;
fun parseLong : forall<a> (s : std/core/types/string, flags : (std/core/list :: V -> V)<(option :: V -> V)<a>>) -> (std/core/total :: E) (flagKind :: V -> V)<a>;
fun parseShorts : forall<a> (s : std/core/types/string, flags : (std/core/list :: V -> V)<(option :: V -> V)<a>>) -> (std/core/list :: V -> V)<(flagKind :: V -> V)<a>>;
fun processNext : forall<a> (arg : std/core/types/string, flags : (std/core/list :: V -> V)<(option :: V -> V)<a>>) -> (std/core/list :: V -> V)<(flagKind :: V -> V)<a>>;
// Parse the command line arguments "args" (see "std/env/argv")
// according to the flag descriptions "flags". Takes an optional argument
// "ordering" that specifies how flags are handled that follow nonFlag arguments.
// The default ordering is "Permute". Returns three lists: the list of parsed options,
// a list of nonOption arguments, and a list of potential error messages.
pub fun parse : forall<a> (initial : a, flags : (std/core/list :: V -> V)<(option :: V -> V)<a>>, args : (std/core/list :: V -> V)<std/core/types/string>, ordering : (std/core/types/optional :: V -> V)<(optionOrder :: V -> V)<a>>) -> (std/core/total :: E) (a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>);
pub fun test : (cmdargs : (std/core/list :: V -> V)<std/core/types/string>) -> <(std/core/console :: X)> ();
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
specialize "_*_*" fun parse // inline size: 1
  = forall<a> fn<(std/core/total :: E)>(initial: a, flags: (std/core/list :: V -> V)<(option :: V -> V)<a>>, args: (std/core/list :: V -> V)<std/core/types/string>, ordering: (std/core/types/optional :: V -> V)<(optionOrder :: V -> V)<a>>){
    std/core/types/unsafe-no-local-cast<(a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>),(std/core/total :: E)>((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(){
      std/core/hnd/local-var<std/core/types/bool,(a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>),(std/core/total :: E),(h :: H)>(std/core/types/False, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(done: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/bool>){
          val opts0 : ((std/core/list :: V -> V)<(std/core/list :: V -> V)<(flagKind :: V -> V)<a>>>)
                = (std/core/map.5<std/core/types/string,(std/core/list :: V -> V)<(flagKind :: V -> V)<a>>,<(std/core/types/local :: H -> X)<(h :: H)>>>(args, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(arg0: std/core/types/string){
                    val opts : ((std/core/list :: V -> V)<(flagKind :: V -> V)<a>>)
                      = (match ((std/core/types/local-get<std/core/types/bool,(h :: H),(std/core/total :: E)>(done))) {
                        ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
                           -> std/core/Cons<(flagKind :: V -> V)<a>>((compat/flags/Arg<a>(arg0)), (std/core/Nil<(flagKind :: V -> V)<a>>));
                        ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
                           -> compat/flags/processNext<a>(arg0, flags);
                      });
                    val _ : ()
                      = (std/core/foreach<(flagKind :: V -> V)<a>,<(std/core/types/local :: H -> X)<(h :: H)>>>(opts, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(opt: (flagKind :: V -> V)<a>){
                          (match (opt) {
                            ((compat/flags/End() : (flagKind :: V -> V)<a> ) as .pat3: ((flagKind :: V -> V)<a>))
                               -> std/core/types/local-set<std/core/types/bool,(std/core/total :: E),(h :: H)>(done, std/core/types/True);
                            ((compat/flags/Arg((.pat5: std/core/types/string) : std/core/types/string) : (flagKind :: V -> V)<a> ) as .pat4: ((flagKind :: V -> V)<a>))
                               | (match ((match (ordering) {
                                ((std/core/types/Optional((.ordering.6173: (optionOrder :: V -> V)<a>) : (optionOrder :: V -> V)<a>) : (std/core/types/optional :: V -> V)<(optionOrder :: V -> V)<a>> ) as .pat6: ((std/core/types/optional :: V -> V)<(optionOrder :: V -> V)<a>>))
                                   -> .ordering.6173;
                                ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<(optionOrder :: V -> V)<a>> ) as .pat00: ((std/core/types/optional :: V -> V)<(optionOrder :: V -> V)<a>>))
                                   -> compat/flags/Permute<a>;
                              })) {
                                ((compat/flags/Preorder() : (optionOrder :: V -> V)<a> ) as .pat: ((optionOrder :: V -> V)<a>))
                                   -> std/core/types/True;
                                (.pat0: ((optionOrder :: V -> V)<a>))
                                   -> std/core/types/False;
                              }) -> std/core/types/local-set<std/core/types/bool,(std/core/total :: E),(h :: H)>(done, std/core/types/True);
                            (.pat60: ((flagKind :: V -> V)<a>))
                               -> std/core/types/();
                          });
                        })));
                    opts;
                  })));
          (std/core/foldl<(flagKind :: V -> V)<a>,(a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>),<(std/core/types/local :: H -> X)<(h :: H)>>>((std/core/.lift17183-concat<(flagKind :: V -> V)<a>>((std/core/Nil<(flagKind :: V -> V)<a>>), opts0)), (std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>(initial, (std/core/Nil<std/core/types/string>), (std/core/Nil<std/core/types/string>))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(acc: (a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>), opt0: (flagKind :: V -> V)<a>){
              (match (acc) {
                ((.skip std/core/types/(,,)((o: a) : a, (xs: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (errs: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>) ) as .pat7: (a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>))
                   -> (match (opt0) {
                    ((compat/flags/Flg((set: (a) -> a) : (a) -> a) : (flagKind :: V -> V)<a> ) as .pat8: ((flagKind :: V -> V)<a>))
                       -> std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>((set(o)), xs, errs);
                    ((compat/flags/Unknown((e: std/core/types/string) : std/core/types/string) : (flagKind :: V -> V)<a> ) as .pat9: ((flagKind :: V -> V)<a>))
                       -> val left.7075 : std/core/types/string
                                = std/core/(++.1)("unrecognized option \x22", e);
                      std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>(o, xs, (std/core/Cons<std/core/types/string>((std/core/(++.1)(left.7075, "\x22")), errs)));
                    ((compat/flags/Error((e0: std/core/types/string) : std/core/types/string) : (flagKind :: V -> V)<a> ) as .pat10: ((flagKind :: V -> V)<a>))
                       -> std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>(o, xs, (std/core/Cons<std/core/types/string>(e0, errs)));
                    ((compat/flags/Arg((x: std/core/types/string) : std/core/types/string) : (flagKind :: V -> V)<a> ) as .pat11: ((flagKind :: V -> V)<a>))
                       -> std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>(o, (std/core/Cons<std/core/types/string>(x, xs)), errs);
                    ((.skip compat/flags/End() : (flagKind :: V -> V)<a> ) as .pat12: ((flagKind :: V -> V)<a>))
                       -> std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>(o, xs, errs);
                  });
              });
            })));
        }));
    }))();
  };
specialize "**" fun parseShorts // inline size: 1
  = forall<a> fn(s: std/core/types/string, flags: (std/core/list :: V -> V)<(option :: V -> V)<a>>){
    std/core/types/unsafe-no-local-cast<(std/core/list :: V -> V)<(flagKind :: V -> V)<a>>,(std/core/types/(<>) :: E)>((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(){
      std/core/hnd/local-var<std/core/types/bool,(std/core/list :: V -> V)<(flagKind :: V -> V)<a>>,(std/core/types/(<>) :: E),(h :: H)>(std/core/types/False, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(done: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/bool>){
          val fs : ((std/core/list :: V -> V)<(std/core/types/maybe :: V -> V)<(flagKind :: V -> V)<a>>>)
            = (std/core/map-indexed<std/core/types/char,(std/core/types/maybe :: V -> V)<(flagKind :: V -> V)<a>>,<(std/core/types/local :: H -> X)<(h :: H)>>>((std/core/list.6(s)), (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(i: std/core/types/int, c: std/core/types/char){
                (match ((std/core/types/local-get<std/core/types/bool,(h :: H),(std/core/types/(<>) :: E)>(done))) {
                  ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
                     -> std/core/types/Nothing<(flagKind :: V -> V)<a>>;
                  ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
                     -> val right.7060 : std/core/types/string
                          = std/core/string(c);
                        val opt : std/core/types/string
                          = std/core/(++.1)("-", right.7060);
                        val applicable : (std/core/list :: V -> V)<(option :: V -> V)<a>>
                          = std/core/filter<(option :: V -> V)<a>,<(std/core/types/local :: H -> X)<(h :: H)>>>(flags, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(flag: (option :: V -> V)<a>){
                              (compat/contains((match (flag) {
                                  ((.skip compat/flags/Option((.x: std/core/types/string) : std/core/types/string, (.pat00: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat10: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat1: ((option :: V -> V)<a>))
                                     -> .x;
                                }), c));
                            }));
                    (match (applicable) {
                      ((std/core/Nil() : (std/core/list :: V -> V)<(option :: V -> V)<a>> ) as .pat11: ((std/core/list :: V -> V)<(option :: V -> V)<a>>))
                         -> val left.7039 : std/core/types/string
                                  = std/core/(++.1)("unrecognized option \x22", opt);
                        std/core/types/Just<(flagKind :: V -> V)<a>>((compat/flags/Error<a>((std/core/(++.1)(left.7039, "\x22")))));
                      ((.skip std/core/Cons((.pat30: (option :: V -> V)<a>) : (option :: V -> V)<a>, ((std/core/Cons((.pat5: (option :: V -> V)<a>) : (option :: V -> V)<a>, (.pat6: (std/core/list :: V -> V)<(option :: V -> V)<a>>) : (std/core/list :: V -> V)<(option :: V -> V)<a>>) : (std/core/list :: V -> V)<(option :: V -> V)<a>> ) as .pat4: (std/core/list :: V -> V)<(option :: V -> V)<a>>) : (std/core/list :: V -> V)<(option :: V -> V)<a>>) : (std/core/list :: V -> V)<(option :: V -> V)<a>> ) as .pat20: ((std/core/list :: V -> V)<(option :: V -> V)<a>>))
                         -> val left.7034 : std/core/types/string
                              = std/core/(++.1)("option \x22", opt);
                            val header : std/core/types/string
                              = std/core/(++.1)(left.7034, "\x22 is ambiguous. It could be one of:");
                        std/core/types/Just<(flagKind :: V -> V)<a>>((compat/flags/Error<a>((compat/flags/usageInfo<a>(applicable, header)))));
                      ((.skip std/core/Cons((desc: (option :: V -> V)<a>) : (option :: V -> V)<a>, ((.skip std/core/Nil() : (std/core/list :: V -> V)<(option :: V -> V)<a>> ) as .pat8: (std/core/list :: V -> V)<(option :: V -> V)<a>>) : (std/core/list :: V -> V)<(option :: V -> V)<a>>) : (std/core/list :: V -> V)<(option :: V -> V)<a>> ) as .pat7: ((std/core/list :: V -> V)<(option :: V -> V)<a>>))
                         -> (match (desc) {
                          ((.skip compat/flags/Option((.pat01: std/core/types/string) : std/core/types/string, (.pat12: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.x0: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.pat21: std/core/types/string) : std/core/types/string, (.pat31: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat9: ((option :: V -> V)<a>))
                             -> (match (.x0) {
                              ((compat/flags/Flag((set: (a, std/core/types/bool) -> a) : (a, std/core/types/bool) -> a) : (optionArg :: V -> V)<a> ) as .pat90: ((optionArg :: V -> V)<a>))
                                 -> std/core/types/Just<(flagKind :: V -> V)<a>>((compat/flags/Flg<a>((fn(o: a){
                                  (set(o, std/core/types/True));
                                }))));
                              ((compat/flags/Req((parse0: (a, std/core/types/string) -> a) : (a, std/core/types/string) -> a, (help0: std/core/types/string) : std/core/types/string) : (optionArg :: V -> V)<a> ) as .pat100: ((optionArg :: V -> V)<a>))
                                 -> val arg0 : std/core/types/string
                                          = compat/substr(s, (std/core/int-add(i, 1)));
                                (match ((std/core/(>.1)((std/core/count.1(arg0)), 0))) {
                                  ((std/core/types/True() : std/core/types/bool ) as .pat110: std/core/types/bool)
                                     -> val _0 : ()
                                              = std/core/types/local-set<std/core/types/bool,(std/core/types/(<>) :: E),(h :: H)>(done, std/core/types/True);
                                    std/core/types/Just<(flagKind :: V -> V)<a>>((compat/flags/Flg<a>((fn(o0: a){
                                      (parse0(o0, arg0));
                                    }))));
                                  ((.skip std/core/types/False() : std/core/types/bool ) as .pat120: std/core/types/bool)
                                     -> val left0.6924 : std/core/types/string
                                          = std/core/(++.1)("option \x22", opt);
                                        val left.6922 : std/core/types/string
                                          = std/core/(++.1)(left0.6924, "\x22 requires an argument ");
                                    std/core/types/Just<(flagKind :: V -> V)<a>>((compat/flags/Error<a>((std/core/(++.1)(left.6922, help0)))));
                                });
                              ((.skip compat/flags/Opt((parse00: (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a) : (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, (.pat14: std/core/types/string) : std/core/types/string) : (optionArg :: V -> V)<a> ) as .pat13: ((optionArg :: V -> V)<a>))
                                 -> val arg00 : std/core/types/string
                                          = compat/substr(s, (std/core/int-add(i, 1)));
                                (match ((std/core/(>.1)((std/core/count.1(arg00)), 0))) {
                                  ((std/core/types/True() : std/core/types/bool ) as .pat15: std/core/types/bool)
                                     -> val _1 : ()
                                              = std/core/types/local-set<std/core/types/bool,(std/core/types/(<>) :: E),(h :: H)>(done, std/core/types/True);
                                    std/core/types/Just<(flagKind :: V -> V)<a>>((compat/flags/Flg<a>((fn(o1: a){
                                      (parse00(o1, (std/core/types/Just<std/core/types/string>(arg00))));
                                    }))));
                                  ((.skip std/core/types/False() : std/core/types/bool ) as .pat16: std/core/types/bool)
                                     -> std/core/types/Just<(flagKind :: V -> V)<a>>((compat/flags/Flg<a>((fn(o2: a){
                                      (parse00(o2, (std/core/types/Nothing<std/core/types/string>)));
                                    }))));
                                });
                            });
                        });
                    });
                });
              })));
          val xss.7069 : ((std/core/list :: V -> V)<(std/core/list :: V -> V)<(flagKind :: V -> V)<a>>>)
            = (std/core/map.5<(std/core/types/maybe :: V -> V)<(flagKind :: V -> V)<a>>,(std/core/list :: V -> V)<(flagKind :: V -> V)<a>>,<(std/core/types/local :: H -> X)<(h :: H)>>>(fs, (std/core/list.5<(flagKind :: V -> V)<a>>)));
          (std/core/.lift17183-concat<(flagKind :: V -> V)<a>>((std/core/Nil<(flagKind :: V -> V)<a>>), xss.7069));
        }));
    }))();
  };
specialize "**" fun processNext // inline size: 1
  = forall<a> fn(arg0: std/core/types/string, flags: (std/core/list :: V -> V)<(option :: V -> V)<a>>){
    (match ((std/core/(==.3)("--", arg0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/Cons<(flagKind :: V -> V)<a>>((compat/flags/End<a>), (std/core/Nil<(flagKind :: V -> V)<a>>));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((compat/startsWith(arg0, "--"))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/Cons<(flagKind :: V -> V)<a>>((compat/flags/parseLong<a>((compat/substr(arg0, 2)), flags)), (std/core/Nil<(flagKind :: V -> V)<a>>));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> (match ((compat/startsWith(arg0, "-"))) {
              ((std/core/types/True() : std/core/types/bool ) as .pat3: std/core/types/bool)
                 -> (match ((std/core/(>=.1)((std/core/count.1(arg0)), 2))) {
                  ((std/core/types/True() : std/core/types/bool ) as .pat5: std/core/types/bool)
                     -> compat/flags/parseShorts<a>((compat/substr(arg0, 1)), flags);
                  ((.skip std/core/types/False() : std/core/types/bool ) as .pat6: std/core/types/bool)
                     -> std/core/Cons<(flagKind :: V -> V)<a>>((compat/flags/Arg<a>(arg0)), (std/core/Nil<(flagKind :: V -> V)<a>>));
                });
              (.pat4: std/core/types/bool)
                 -> std/core/Cons<(flagKind :: V -> V)<a>>((compat/flags/Arg<a>(arg0)), (std/core/Nil<(flagKind :: V -> V)<a>>));
            });
        });
    });
  };
specialize "*" fun showFlag // inline size: 1
  = forall<a> fn(flag: (option :: V -> V)<a>){
    val xs.6977 : (std/core/list :: V -> V)<std/core/types/string>
      = std/core/map.5<std/core/types/char,std/core/types/string,(std/core/types/(<>) :: E)>((std/core/list.6((match (flag) {
          ((.skip compat/flags/Option((.x: std/core/types/string) : std/core/types/string, (.pat0: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat1: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat: ((option :: V -> V)<a>))
             -> .x;
        }))), (fn(c: std/core/types/char){
          val right0.6983 : std/core/types/string
            = (std/core/string(c));
          val left.6980 : std/core/types/string
            = (std/core/(++.1)("-", right0.6983));
          val right.6981 : std/core/types/string
            = (match (flag) {
              ((.skip compat/flags/Option((.pat000: std/core/types/string) : std/core/types/string, (.pat100: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.x0: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.pat200: std/core/types/string) : std/core/types/string, (.pat300: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat41: ((option :: V -> V)<a>))
                 -> (match (.x0) {
                  ((compat/flags/Flag((.pat00: (a, std/core/types/bool) -> a) : (a, std/core/types/bool) -> a) : (optionArg :: V -> V)<a> ) as .pat4: ((optionArg :: V -> V)<a>))
                     -> "";
                  ((compat/flags/Req((.pat20: (a, std/core/types/string) -> a) : (a, std/core/types/string) -> a, (h: std/core/types/string) : std/core/types/string) : (optionArg :: V -> V)<a> ) as .pat10: ((optionArg :: V -> V)<a>))
                     -> val left.6903 : std/core/types/string
                              = std/core/(++.1)("<", h);
                    std/core/(++.1)(left.6903, ">");
                  ((.skip compat/flags/Opt((.pat40: (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a) : (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, (h0: std/core/types/string) : std/core/types/string) : (optionArg :: V -> V)<a> ) as .pat30: ((optionArg :: V -> V)<a>))
                     -> val left1.6907 : std/core/types/string
                              = std/core/(++.1)("[", h0);
                    std/core/(++.1)(left1.6907, "]");
                });
            });
          (std/core/(++.1)(left.6980, right.6981));
        }));
    val short : std/core/types/string
      = (match (xs.6977) {
        ((std/core/Nil() : (std/core/list :: V -> V)<std/core/types/string> ) as .pat11: ((std/core/list :: V -> V)<std/core/types/string>))
           -> "";
        ((.skip std/core/Cons((x: std/core/types/string) : std/core/types/string, (xx: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string> ) as .pat21: ((std/core/list :: V -> V)<std/core/types/string>))
           -> std/core/.lift17188-joinsep(" ", xx, x);
      });
    val xs0.6985 : (std/core/list :: V -> V)<std/core/types/string>
      = std/core/map.5<std/core/types/string,std/core/types/string,(std/core/types/(<>) :: E)>((match (flag) {
          ((.skip compat/flags/Option((.pat01: std/core/types/string) : std/core/types/string, (.x1: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat110: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.pat210: std/core/types/string) : std/core/types/string, (.pat31: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat5: ((option :: V -> V)<a>))
             -> .x1;
        }), (fn(name0: std/core/types/string){
          val left1.6988 : std/core/types/string
            = (std/core/(++.1)("--", name0));
          val right1.6989 : std/core/types/string
            = (match (flag) {
              ((.skip compat/flags/Option((.pat03: std/core/types/string) : std/core/types/string, (.pat13: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.x2: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.pat23: std/core/types/string) : std/core/types/string, (.pat33: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat7: ((option :: V -> V)<a>))
                 -> (match (.x2) {
                  ((compat/flags/Flag((.pat02: (a, std/core/types/bool) -> a) : (a, std/core/types/bool) -> a) : (optionArg :: V -> V)<a> ) as .pat6: ((optionArg :: V -> V)<a>))
                     -> "";
                  ((compat/flags/Req((.pat22: (a, std/core/types/string) -> a) : (a, std/core/types/string) -> a, (h1: std/core/types/string) : std/core/types/string) : (optionArg :: V -> V)<a> ) as .pat12: ((optionArg :: V -> V)<a>))
                     -> std/core/(++.1)("=", h1);
                  ((.skip compat/flags/Opt((.pat400: (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a) : (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, (h00: std/core/types/string) : std/core/types/string) : (optionArg :: V -> V)<a> ) as .pat32: ((optionArg :: V -> V)<a>))
                     -> val left4.6996 : std/core/types/string
                              = std/core/(++.1)("[=", h00);
                    std/core/(++.1)(left4.6996, "]");
                });
            });
          (std/core/(++.1)(left1.6988, right1.6989));
        }));
    val long : std/core/types/string
      = (match (xs0.6985) {
        ((std/core/Nil() : (std/core/list :: V -> V)<std/core/types/string> ) as .pat14: ((std/core/list :: V -> V)<std/core/types/string>))
           -> "";
        ((.skip std/core/Cons((x0: std/core/types/string) : std/core/types/string, (xx0: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string> ) as .pat24: ((std/core/list :: V -> V)<std/core/types/string>))
           -> std/core/.lift17188-joinsep(" ", xx0, x0);
      });
    val v.17126 : (std/core/types/vector :: V -> V)<std/core/types/string>
      = std/core/splitv((match (flag) {
          ((.skip compat/flags/Option((.pat04: std/core/types/string) : std/core/types/string, (.pat140: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat240: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.x3: std/core/types/string) : std/core/types/string, (.pat34: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat8: ((option :: V -> V)<a>))
             -> .x3;
        }), "\x0A");
    (match ((std/core/vlist<std/core/types/string>(v.17126, (std/core/types/None<(std/core/list :: V -> V)<std/core/types/string>>)))) {
      ((std/core/Cons((hd: std/core/types/string) : std/core/types/string, (tl: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string> ) as .pat9: ((std/core/list :: V -> V)<std/core/types/string>))
         -> val right6.7003 : (std/core/list :: V -> V)<(std/core/types/string, std/core/types/string, std/core/types/string)>
                  = std/core/map.5<std/core/types/string,(std/core/types/string, std/core/types/string, std/core/types/string),(std/core/types/(<>) :: E)>(tl, (fn(s0: std/core/types/string){
                      (std/core/types/(,,)<std/core/types/string,std/core/types/string,std/core/types/string>("", "", s0));
                    }));
        std/core/append<(std/core/types/string, std/core/types/string, std/core/types/string)>((std/core/Cons<(std/core/types/string, std/core/types/string, std/core/types/string)>((std/core/types/(,,)<std/core/types/string,std/core/types/string,std/core/types/string>(short, long, hd)), (std/core/Nil<(std/core/types/string, std/core/types/string, std/core/types/string)>))), right6.7003);
      ((.skip std/core/Nil() : (std/core/list :: V -> V)<std/core/types/string> ) as .pat05: ((std/core/list :: V -> V)<std/core/types/string>))
         -> std/core/Cons<(std/core/types/string, std/core/types/string, std/core/types/string)>((std/core/types/(,,)<std/core/types/string,std/core/types/string,std/core/types/string>(short, long, "")), (std/core/Nil<(std/core/types/string, std/core/types/string, std/core/types/string)>));
    });
  };
specialize "*___" fun zipWith3 // inline size: 1
  = forall<a,b,c,d,(e :: E)> fn<(e :: E)>(f: (a, b, c) -> (e :: E) d, xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>, zs: (std/core/list :: V -> V)<c>){
    compat/flags/zipWith3Acc<a,b,c,d,(e :: E)>(f, (std/core/Nil<d>), xs, ys, zs);
  };
recursive specialize "*____" fun zipWith3Acc // inline size: 12
  = forall<a,b,c,d,(e :: E)> fn<(e :: E)>(f: (a, b, c) -> (e :: E) d, acc: (std/core/list :: V -> V)<d>, xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>, zs: (std/core/list :: V -> V)<c>){
    (match (xs) {
      ((std/core/Nil() : (std/core/list :: V -> V)<a> ) as .pat: ((std/core/list :: V -> V)<a>))
         -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<d>) -> (std/core/list :: V -> V)<d>,(xs : (std/core/list :: V -> V)<d>) -> (e :: E) (std/core/list :: V -> V)<d>>((std/core/reverse<d>))(acc);
      ((.skip std/core/Cons((x: a) : a, (xx: (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a> ) as .pat0: ((std/core/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/Nil() : (std/core/list :: V -> V)<b> ) as .pat1: ((std/core/list :: V -> V)<b>))
             -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<d>) -> (std/core/list :: V -> V)<d>,(xs : (std/core/list :: V -> V)<d>) -> (e :: E) (std/core/list :: V -> V)<d>>((std/core/reverse<d>))(acc);
          ((.skip std/core/Cons((y: b) : b, (yy: (std/core/list :: V -> V)<b>) : (std/core/list :: V -> V)<b>) : (std/core/list :: V -> V)<b> ) as .pat2: ((std/core/list :: V -> V)<b>))
             -> (match (zs) {
              ((std/core/Cons((z: c) : c, (zz: (std/core/list :: V -> V)<c>) : (std/core/list :: V -> V)<c>) : (std/core/list :: V -> V)<c> ) as .pat3: ((std/core/list :: V -> V)<c>))
                 -> compat/flags/zipWith3Acc<a,b,c,d,(e :: E)>(f, (std/core/Cons<d>((f(x, y, z)), acc)), xx, yy, zz);
              ((.skip std/core/Nil() : (std/core/list :: V -> V)<c> ) as .pat4: ((std/core/list :: V -> V)<c>))
                 -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<d>) -> (std/core/list :: V -> V)<d>,(xs : (std/core/list :: V -> V)<d>) -> (e :: E) (std/core/list :: V -> V)<d>>((std/core/reverse<d>))(acc);
            });
        });
    });
  };
inline borrow "^" fun is-flg // inline size: 1
  = forall<a> fn(flagKind: (flagKind :: V -> V)<a>){
    (match (flagKind) {
      ((compat/flags/Flg((.pat0: (a) -> a) : (a) -> a) : (flagKind :: V -> V)<a> ) as .pat: ((flagKind :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((flagKind :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-arg // inline size: 1
  = forall<a> fn(flagKind: (flagKind :: V -> V)<a>){
    (match (flagKind) {
      ((compat/flags/Arg((.pat0: std/core/types/string) : std/core/types/string) : (flagKind :: V -> V)<a> ) as .pat: ((flagKind :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((flagKind :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-end // inline size: 1
  = forall<a> fn(flagKind: (flagKind :: V -> V)<a>){
    (match (flagKind) {
      ((compat/flags/End() : (flagKind :: V -> V)<a> ) as .pat: ((flagKind :: V -> V)<a>))
         -> std/core/types/True;
      (.pat0: ((flagKind :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-unknown // inline size: 1
  = forall<a> fn(flagKind: (flagKind :: V -> V)<a>){
    (match (flagKind) {
      ((compat/flags/Unknown((.pat0: std/core/types/string) : std/core/types/string) : (flagKind :: V -> V)<a> ) as .pat: ((flagKind :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((flagKind :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-error // inline size: 1
  = forall<a> fn(flagKind: (flagKind :: V -> V)<a>){
    (match (flagKind) {
      ((compat/flags/Error((.pat0: std/core/types/string) : std/core/types/string) : (flagKind :: V -> V)<a> ) as .pat: ((flagKind :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((flagKind :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-flag // inline size: 1
  = forall<a> fn(optionArg: (optionArg :: V -> V)<a>){
    (match (optionArg) {
      ((compat/flags/Flag((.pat0: (a, std/core/types/bool) -> a) : (a, std/core/types/bool) -> a) : (optionArg :: V -> V)<a> ) as .pat: ((optionArg :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((optionArg :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-req // inline size: 1
  = forall<a> fn(optionArg: (optionArg :: V -> V)<a>){
    (match (optionArg) {
      ((compat/flags/Req((.pat0: (a, std/core/types/string) -> a) : (a, std/core/types/string) -> a, (.pat1: std/core/types/string) : std/core/types/string) : (optionArg :: V -> V)<a> ) as .pat: ((optionArg :: V -> V)<a>))
         -> std/core/types/True;
      (.pat2: ((optionArg :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-opt // inline size: 1
  = forall<a> fn(optionArg: (optionArg :: V -> V)<a>){
    (match (optionArg) {
      ((compat/flags/Opt((.pat0: (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a) : (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, (.pat1: std/core/types/string) : std/core/types/string) : (optionArg :: V -> V)<a> ) as .pat: ((optionArg :: V -> V)<a>))
         -> std/core/types/True;
      (.pat2: ((optionArg :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun shortNames // inline size: 0
  = forall<a> fn(option: (option :: V -> V)<a>){
    (match (option) {
      ((.skip compat/flags/Option((.x: std/core/types/string) : std/core/types/string, (.pat0: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat1: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat: ((option :: V -> V)<a>))
         -> .x;
    });
  };
inline borrow "^" fun longNames // inline size: 0
  = forall<a> fn(option: (option :: V -> V)<a>){
    (match (option) {
      ((.skip compat/flags/Option((.pat0: std/core/types/string) : std/core/types/string, (.x: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat1: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat: ((option :: V -> V)<a>))
         -> .x;
    });
  };
inline borrow "^" fun arg // inline size: 0
  = forall<a> fn(option: (option :: V -> V)<a>){
    (match (option) {
      ((.skip compat/flags/Option((.pat0: std/core/types/string) : std/core/types/string, (.pat1: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.x: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat: ((option :: V -> V)<a>))
         -> .x;
    });
  };
inline borrow "^" fun help // inline size: 0
  = forall<a> fn(option: (option :: V -> V)<a>){
    (match (option) {
      ((.skip compat/flags/Option((.pat0: std/core/types/string) : std/core/types/string, (.pat1: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat2: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.x: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat: ((option :: V -> V)<a>))
         -> .x;
    });
  };
inline borrow "^" fun llongNames // inline size: 0
  = forall<a> fn(option: (option :: V -> V)<a>){
    (match (option) {
      ((.skip compat/flags/Option((.pat0: std/core/types/string) : std/core/types/string, (.pat1: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat2: (optionArg :: V -> V)<a>) : (optionArg :: V -> V)<a>, (.pat3: std/core/types/string) : std/core/types/string, (.x: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (option :: V -> V)<a> ) as .pat: ((option :: V -> V)<a>))
         -> .x;
    });
  };
inline borrow "^" fun is-permute // inline size: 1
  = forall<a> fn(optionOrder: (optionOrder :: V -> V)<a>){
    (match (optionOrder) {
      ((compat/flags/Permute() : (optionOrder :: V -> V)<a> ) as .pat: ((optionOrder :: V -> V)<a>))
         -> std/core/types/True;
      (.pat0: ((optionOrder :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-preorder // inline size: 1
  = forall<a> fn(optionOrder: (optionOrder :: V -> V)<a>){
    (match (optionOrder) {
      ((compat/flags/Preorder() : (optionOrder :: V -> V)<a> ) as .pat: ((optionOrder :: V -> V)<a>))
         -> std/core/types/True;
      (.pat0: ((optionOrder :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-wrap // inline size: 1
  = forall<a> fn(optionOrder: (optionOrder :: V -> V)<a>){
    (match (optionOrder) {
      ((compat/flags/Wrap((.pat0: (std/core/types/string) -> a) : (std/core/types/string) -> a) : (optionOrder :: V -> V)<a> ) as .pat: ((optionOrder :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((optionOrder :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun verbose // inline size: 0
  = fn(testOptions0: testOptions){
    match (testOptions0) {
      ((.skip compat/flags/TestOptions((.x: std/core/types/bool) : std/core/types/bool, (.pat0: std/core/types/bool) : std/core/types/bool, (.pat1: std/core/types/string) : std/core/types/string, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : testOptions ) as .pat: testOptions)
         -> .x;
    };
  };
inline borrow "^" fun version // inline size: 0
  = fn(testOptions0: testOptions){
    match (testOptions0) {
      ((.skip compat/flags/TestOptions((.pat0: std/core/types/bool) : std/core/types/bool, (.x: std/core/types/bool) : std/core/types/bool, (.pat1: std/core/types/string) : std/core/types/string, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : testOptions ) as .pat: testOptions)
         -> .x;
    };
  };
inline borrow "^" fun name // inline size: 0
  = fn(testOptions0: testOptions){
    match (testOptions0) {
      ((.skip compat/flags/TestOptions((.pat0: std/core/types/bool) : std/core/types/bool, (.pat1: std/core/types/bool) : std/core/types/bool, (.x: std/core/types/string) : std/core/types/string, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : testOptions ) as .pat: testOptions)
         -> .x;
    };
  };
inline borrow "^" fun output // inline size: 0
  = fn(testOptions0: testOptions){
    match (testOptions0) {
      ((.skip compat/flags/TestOptions((.pat0: std/core/types/bool) : std/core/types/bool, (.pat1: std/core/types/bool) : std/core/types/bool, (.pat2: std/core/types/string) : std/core/types/string, (.x: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : testOptions ) as .pat: testOptions)
         -> .x;
    };
  };
inline borrow "^" fun arguments // inline size: 0
  = fn(testOptions0: testOptions){
    match (testOptions0) {
      ((.skip compat/flags/TestOptions((.pat0: std/core/types/bool) : std/core/types/bool, (.pat1: std/core/types/bool) : std/core/types/bool, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: std/core/types/string) : std/core/types/string, (.x: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : testOptions ) as .pat: testOptions)
         -> .x;
    };
  };
fun unzip3 // inline size: 1
  = forall<a,b,c> fn(xs: (std/core/list :: V -> V)<(a, b, c)>){
    compat/flags/.lift7167-unzip3<a,b,c>(xs, (std/core/Nil<a>), (std/core/Nil<b>), (std/core/Nil<c>));
  };
fun errorNegate // inline size: 3
  = forall<a> fn(flagname: std/core/types/string){
    val left.6914 : std/core/types/string
          = std/core/(++.1)("option \x22--", flagname);
    compat/flags/Error<a>((std/core/(++.1)(left.6914, "\x22 cannot be negated")));
  };
fun errorNoarg // inline size: 3
  = forall<a> fn(opt: std/core/types/string){
    val left.6918 : std/core/types/string
          = std/core/(++.1)("option \x22", opt);
    compat/flags/Error<a>((std/core/(++.1)(left.6918, "\x22 does not take an argument")));
  };
fun errorRequired // inline size: 4
  = forall<a> fn(help0: std/core/types/string, opt: std/core/types/string){
    val left0.6924 : std/core/types/string
      = std/core/(++.1)("option \x22", opt);
    val left.6922 : std/core/types/string
      = std/core/(++.1)(left0.6924, "\x22 requires an argument ");
    compat/flags/Error<a>((std/core/(++.1)(left.6922, help0)));
  };
fun errorUnknownMessage // inline size: 2
  = fn(opt: std/core/types/string){
    val left.6928 : std/core/types/string
          = std/core/(++.1)("unrecognized option \x22", opt);
    std/core/(++.1)(left.6928, "\x22");
  };
inline fun .create-Option // inline size: 3
  = forall<a> fn(shortNames0: std/core/types/string, longNames0: (std/core/list :: V -> V)<std/core/types/string>, arg0: (optionArg :: V -> V)<a>, help0: std/core/types/string, llongNames0: (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>){
    val .llongNames.2526 : (std/core/list :: V -> V)<std/core/types/string>
          = (match (llongNames0) {
            ((std/core/types/Optional((.llongNames.2527: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>> ) as .pat: ((std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>))
               -> .llongNames.2527;
            ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>> ) as .pat0: ((std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>))
               -> std/core/map.5<std/core/types/string,std/core/types/string,(std/core/types/(<>) :: E)>(longNames0, compat/toLower);
          });
    compat/flags/Option<a>(shortNames0, longNames0, arg0, help0, .llongNames.2526);
  };
inline fun .create-TestOptions // inline size: 6
  = fn(verbose0: (std/core/types/optional :: V -> V)<std/core/types/bool>, version0: (std/core/types/optional :: V -> V)<std/core/types/bool>, name0: (std/core/types/optional :: V -> V)<std/core/types/string>, output0: (std/core/types/optional :: V -> V)<std/core/types/string>, arguments0: (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>){
    compat/flags/TestOptions((match (verbose0) {
        ((std/core/types/Optional((.verbose.2632: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> .verbose.2632;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> std/core/types/False;
      }), (match (version0) {
        ((std/core/types/Optional((.version.2636: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat1: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> .version.2636;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> std/core/types/False;
      }), (match (name0) {
        ((std/core/types/Optional((.name.2640: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat3: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> .name.2640;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat4: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> "";
      }), (match (output0) {
        ((std/core/types/Optional((.output.2644: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat5: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> .output.2644;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat6: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> "";
      }), (match (arguments0) {
        ((std/core/types/Optional((.arguments.2649: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>> ) as .pat7: ((std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>))
           -> .arguments.2649;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>> ) as .pat8: ((std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>))
           -> std/core/Nil<std/core/types/string>;
      }));
  };
fun zipWith3 // inline size: 1
  = forall<a,b,c,d,(e :: E)> fn<(e :: E)>(f: (a, b, c) -> (e :: E) d, xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>, zs: (std/core/list :: V -> V)<c>){
    compat/flags/zipWith3Acc<a,b,c,d,(e :: E)>(f, (std/core/Nil<d>), xs, ys, zs);
  };
fun errorAmbiguous // inline size: 4
  = forall<a,b> fn(applicable: (std/core/list :: V -> V)<(option :: V -> V)<a>>, opt: std/core/types/string){
    val left.7034 : std/core/types/string
      = std/core/(++.1)("option \x22", opt);
    val header : std/core/types/string
      = std/core/(++.1)(left.7034, "\x22 is ambiguous. It could be one of:");
    compat/flags/Error<b>((compat/flags/usageInfo<a>(applicable, header)));
  };
fun errorUnknown // inline size: 3
  = forall<a> fn(opt: std/core/types/string){
    val left.7039 : std/core/types/string
          = std/core/(++.1)("unrecognized option \x22", opt);
    compat/flags/Error<a>((std/core/(++.1)(left.7039, "\x22")));
  };