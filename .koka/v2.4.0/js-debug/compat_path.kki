/*
Handle and transform file paths 
*/
module interface compat/path
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core = std/core = "";
import compat = compat = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// The `:io` effect is used for functions that perform arbitrary I/O operations.
local alias std/core/io :: E = <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,((std/core/io-noexn :: E) == 3 <(std/core/types/div :: X),((std/core/io-total :: E) == 2 <(std/core/types/ndet :: X),(std/core/console :: X),(std/core/net :: X),(std/core/fsys :: X),(std/core/ui :: X),((std/core/types/st :: H -> E)<(std/core/types/global :: H)> == 1 <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>>)>)>)> = 4;
 
//------------------------------
//#kki: type declarations
 
 
//------------------------------
//#kki: declarations
 
pub fun pathsep : () -> std/core/types/string;
pub fun xdirname : (p : std/core/types/string) -> std/core/types/string;
// Return the extension (including the `.`)  
// `extname("foo.ext") == ".ext"`, `extname("bla.") == "."`, `extname("bla") == ""` 
pub fun extname_old : (p : std/core/types/string) -> std/core/types/string;
// Return the base name (file name) portion of the path.
// `basename("foo/bar.ext") == "bar.ext"`
pub fun basename : (p : std/core/types/string) -> std/core/types/string;
pub fun pathdelim : () -> std/core/types/string;
// Return the full normalized path
pub fun normalize : (p : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
pub fun programPath : () -> <(std/core/io :: E)> std/core/types/string;
// Platform specific directory separator (`/` or `\`)
pub val sep : std/core/types/string;
// Join arguments using the platform specific directory separator  
// Note: unlike NodeJS the resulting path is not yet normalized
pub fun combine : (path1 : std/core/types/string, path2 : std/core/types/string) -> std/core/types/string;
// Join a list of paths 
pub fun combine.1 : (paths : (std/core/list :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Return the directory name portion of the path (excluding the directory separator).
// Return an empty string if no directory part exists in the path.  
// `dirname("foo/bar.ext") == "foo")`
pub fun dirname : (p : std/core/types/string) -> std/core/types/string;
// Remove the extension from a path
pub fun noext : (path : std/core/types/string) -> std/core/types/string;
// Return the stem name portion of the path, i.e. without directory or extension.
// `stemname("foo/bar.ext") == "bar"`
pub fun stemname : (p : std/core/types/string) -> std/core/types/string;
// Append to the stem name of a path
pub fun appendStem : (path : std/core/types/string, extra : std/core/types/string) -> std/core/types/string;
// Change the extension of a path
pub fun changeExt : (path : std/core/types/string, ext : std/core/types/string) -> std/core/types/string;
// If a path has no extension, set it to the provided one.
pub fun defaultExt : (fname : std/core/types/string, ext : std/core/types/string) -> std/core/types/string;
// Platform specific path delimiter when specifying a list o paths (`:` or `;`)
pub val delimiter : std/core/types/string;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
fun combine.1 // inline size: 2
  = fn(paths: (std/core/list :: V -> V)<std/core/types/string>){
    match (paths) {
      ((std/core/Nil() : (std/core/list :: V -> V)<std/core/types/string> ) as .pat: ((std/core/list :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/Cons((p: std/core/types/string) : std/core/types/string, (ps: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string> ) as .pat0: ((std/core/list :: V -> V)<std/core/types/string>))
         -> std/core/foldl<std/core/types/string,std/core/types/string,(std/core/types/(<>) :: E)>(ps, p, compat/path/combine);
    };
  };
fun stemname // inline size: 2
  = fn(p: std/core/types/string){
    compat/path/noext((compat/path/basename(p)));
  };
fun defaultExt // inline size: 4
  = fn(fname: std/core/types/string, ext: std/core/types/string){
    match ((std/core/(==.3)((compat/path/extname_old(fname)), ""))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> compat/path/changeExt(fname, ext);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> fname;
    };
  };