/* Double-double 128-bit floating point numbers.

The `:ddouble` type implements [double double][ddwiki] 128-bit floating point numbers
as a pair of IEEE `:float64` values. This extends the precision to 31 decimal digits
(versus 15 for `:float64`), but keeps the same range as
a `:float64` with a maximum  value of about 1.8&middot;10^308^ (`dd-max`). Because
`:float64`s usually have hardware support, a `:ddouble` is usually much faster
than arbitrary precision floating point numbers.

## Precision {-}

If you add two regular 64-bit `:float64` values you can quickly notice the imprecision
due to decimal fractions that cannot be represented precisely. For example:
```
> 0.1 + 0.2
0.30000000000000004
```

This happens because the decimal `0.1` and `0.2` cannot be represented exactly
by a `:float64` which is encoded in base 2. For example, if we show `0.1` to 20 digits, we get:
```
> 0.1.show(20)
"0.10000000000000000555"
```

When we convert the constant `0.1` to a `:ddouble` we can see with even more precision how it is
approximated:

```
> 0.1.ddouble
0.1000000000000000055511151231258
```

However, if we convert the number `0.1` directly to a `:ddouble` (instead of going through
a `:float64` constant), we can represent `0.1` more precisely:

```
> ddouble("0.1")   // for convenience; using `ddouble-exp(1,-1)` is more efficient
0.1
```

This is possible because a `:ddouble` uses two `:float64`s to represent numbers; in this
case the first (_hi_) float64 is (the inexact) `0.1` while the second one (_lo_) is the
correction to that number. The `show-sum`  (or `show-hex`) function shows this internal pair of numbers:

```
> ddouble("0.1").show-sum(20)
"0.10000000000000000555 + -5.55111512312578301027e-18"

> ddouble("0.1") + ddouble("0.2")
0.3
```

Generally, a `:ddouble` _d_ is represented by a pair of `:float64`s, _hi_ and _lo_,
such that _d_ equals _hi_+_lo_, where \|_lo_\| &le; 0.5&middot;ulp(_hi_).
Note that despite the extra precision, underflow/overflow and machine precision are
not as well-defined as with a regular `:float64` [@lin;@shewchuk;@Dekker].
Nevertheless, using a `:ddouble` often prevents instability in practice over
`:float64` computations due to  rounding errors or combining very large and
small numbers.

Take the "thin triangle" problem for example [@Goldberg:float;@Kahan:triangle].
The challenge is to compute
the area of a very thin triangle with sides $a$, $b$, and $c$. The short sides
 $b$ and $c$ are just 3 units in the last place (ulp) shorter than
the longest side $a$. Using the value $s = (a + b + c)/2$, the area of
a triangle is $A = \sqrt{s(s-a)(s-b)(s-c)}$. This is troublesome if $s$ is
close to $a$ since $s-a$ magnifies any rounding error. Let's take $a=7$,
and $b = c = 7/2 + 3\cdot2^{-111}$; according to [@gustafson:posit],
&ldquo;If the units are in light-years, then the short sides are only longer than
half the long side by $1/200$th the diameter of a proton. Yet that pops the triangle
up to about the width of a doorway at the thickest point&rdquo;. Using various
128-bit numbers we get:
````
exact          : 3.14784204874900425235885265494550774498...e-16
128-bit ddouble: 3.147842048749004252358852654945\([47]{color:#F88}\)e-16
128-bit posit  : 3.147842048749004252358852654945507744\([39]{color:#F88}\)e-16
128-bit ieee   : 3.\([63481490842332134725920516158057682878]{color:#F88}\)e-16
````
For this kind of example, a `:ddouble` has better precision than a
regular 128-bit IEEE float since it can combine very large and
small values. (Kahan [@Kahan:triangle] shows how to rewrite the equations
to avoid magnifying rounding errors -- in that case the result for
IEEE 128-bit floats becomes:
````
128-bit ieee x : 3.147842048749004252358852654945507\([92210]{color:#F88}\)e-16
````

The implementation is based closely on the [QD] C++ library [@Hida:qd;@Hida:qdlib],
and assumes proper 64-bit IEEE `:float64`s with correct rounding.
Integers can be represented precisely up to 30 decimal digits (and a bit more...
up to 2^106^ - 2).

## References {-}

~ Bibliography { caption:"0" }

~~ BibItem { #dekker; bibitem-label:"[1]"; searchterm:"Dekker+A+Floating-Point+Technique+for+Extending+the+Available+Precision" }
T.\ Dekker.
_A Floating-Point Technique for Extending the Available Precision_.
Numerische\ Mathematik, vol. 18 (3), June 1971, 224--242.
[pdf](http://gdz.sub.uni-goettingen.de/dms/resolveppn/?PPN=GDZPPN001170007).
~~

~~ BibItem { #Goldberg:float; bibitem-label:"[2]"}
David Goldberg.
_What Every Computer Scientist Should Know About Floating-point Arithmetic_.
ACM Computing Survey. vol. 23 (1), March 1991. doi: [10.1145/103162.103163](http://doi.org/10.1145/103162.103163).
[pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&rep=rep1&type=pdf).
~~

~~ BibItem { #Gustafson:posit; bibitem-label:"[3]"; searchterm:"Gustafson+John+Beating+floating+point+at+its+own+game+posit+arithmetic"; }
John\ L. Gustafson and Isaac\ Yonemoto.
_Beating Floating Point at its Own Game: Posit Arithmetic_. 2017.
[pdf](http://www.johngustafson.net/pdfs/BeatingFloatingPoint.pdf).
~~

~~ BibItem { #Hida:qd; bibitem-label:"[4]"; searchterm:"Hida+Quad-Double+Arithmetic:+Algorithms,+Implementation,+and+Application" }
Yozo Hida,\ Xiaoye S.\ Li, and David\ H.\ Bailey.
_Quad-Double Arithmetic: Algorithms, Implementation, and Application_.
Lawrence Berkeley National Laboratory Technical Report LBNL-46996. 2000. [pdf](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.5769).
~~

~~ BibItem { #Hida:qdlib; bibitem-label:"[5]"; searchterm:"Hida+Library+for+double-double+and+quad-double+arithmetic" }
Yozo Hida,\ Xiaoye\ S.\ Li, and David\ H.\ Bailey.
_Library for double-double and quad-double arithmetic._
(2007). [pdf](http://www.jaist.ac.jp/~s1410018/papers/qd.pdf).
~~

~~ Bibitem { #lin; bibitem-label:"[6]"; searchterm:'Linnainmaa+"Software+for+Doubled-Precision+Floating-Point+Computations"' }
Seppo\ Linnainmaa.
_Software for Doubled-Precision Floating-Point Computations_.
ACM Transactions on Mathematical Software (TOMS), vol. 7 (3), Sept. 1981, 272--283.
~~

~~ Bibitem { #Kahan:triangle; bibitem-label:"[7]"}
William\ Kahan.
_Miscalculating Area and Angles of a Needle-like Triangle_.
Lecture notes, 2004, [pdf](https://people.eecs.berkeley.edu/~wkahan/Triangle.pdf).
~~

~~ BibItem { #shewchuk; bibitem-label:"[8]"; }
Jonathan\ Richard\ Shewchuk.
_Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates_.
Discrete & Computational Geometry, vol. 18, 305--363, 1997. [pdf](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
~~

~

[ddwiki]: https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic
[qd]:     http://crd-legacy.lbl.gov/~dhbailey/mpdist

\/
*/
module interface std/num/ddouble
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core/hnd = std/core/hnd = "";
import std/core = std/core = "";
import std/text/parse = std/text/parse = "";
import std/num/float64 = std/num/float64 = "";
import std/num/decimal = std/num/decimal = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 
/* The `:ddouble` type implements [float64 float64][ddwiki] 128-bit floating point numbers
as a pair of IEEE `:float64` values. This extends the precision to 31 decimal digits
(versus 15 for `:float64`), but keeps the same range as
a `:float64` with a maximum  value of about 1.8&middot;10^308^. Because
`:float64`s usually have hardware support, a `:ddouble` is usually much faster
than arbitrary precision floating point numbers.

Internally a `:ddouble` _d_ is represented as a pair of `:float64`s, _hi_ and _lo_,
such that the number represented by _d_ is _hi_+_lo_, where \|_lo_\| &le; 0.5&middot;ulp(_hi_).
*/
pub value{16,0} type ddouble {
  /* The `:ddouble` type implements [float64 float64][ddwiki] 128-bit floating point numbers
as a pair of IEEE `:float64` values. This extends the precision to 31 decimal digits
(versus 15 for `:float64`), but keeps the same range as
a `:float64` with a maximum  value of about 1.8&middot;10^308^. Because
`:float64`s usually have hardware support, a `:ddouble` is usually much faster
than arbitrary precision floating point numbers.

Internally a `:ddouble` _d_ is represented as a pair of `:float64`s, _hi_ and _lo_,
such that the number represented by _d_ is _hi_+_lo_, where \|_lo_\| &le; 0.5&middot;ulp(_hi_).
*/
  con Ddouble(hi: std/core/types/float64, lo: std/core/types/float64) : (hi : std/core/types/float64, lo : std/core/types/float64) -> ddouble;
};
value{16,0} type edouble {
  con Edouble(num: std/core/types/float64, err: std/core/types/float64) : (num : std/core/types/float64, err : std/core/types/float64) -> edouble;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `hi` constructor field of the `:ddouble` type.
fun hi : (^ ddouble : ddouble) -> std/core/types/float64;
// Automatically generated. Retrieves the `lo` constructor field of the `:ddouble` type.
fun lo : (^ ddouble : ddouble) -> std/core/types/float64;
pub fun .copy : (.this : ddouble, hi : (std/core/types/optional :: V -> V)<std/core/types/float64>, lo : (std/core/types/optional :: V -> V)<std/core/types/float64>) -> ddouble;
// Automatically generated. Retrieves the `num` constructor field of the `:edouble` type.
fun num : (^ edouble : edouble) -> std/core/types/float64;
// Automatically generated. Retrieves the `err` constructor field of the `:edouble` type.
fun err : (^ edouble : edouble) -> std/core/types/float64;
fun .copy.1 : (.this : edouble, num : (std/core/types/optional :: V -> V)<std/core/types/float64>, err : (std/core/types/optional :: V -> V)<std/core/types/float64>) -> edouble;
val maxprecise : std/core/types/int;
// Convert a `:ddouble` to a `:float64` (losing precision)
pub fun float64 : (x : ddouble) -> std/core/types/float64;
val dd-default-prec : std/core/types/int;
// maximal precision in decimal digits of a `:ddouble`.
pub val dd-max-prec : std/core/types/int;
// Decode a `:ddouble` `d` into two doubles `(hi,lo)` such that `d` equals  `hi`+`lo`,
// where `lo` &le; 0.5&middot;ulp(`hi`).
pub fun decode : (d : ddouble) -> (std/core/types/float64, std/core/types/float64);
// Compare two `:ddouble` values.
pub fun compare : (x : ddouble, y : ddouble) -> std/core/types/order;
pub fun (!=) : (x : ddouble, y : ddouble) -> std/core/types/bool;
pub fun (<=) : (x : ddouble, y : ddouble) -> std/core/types/bool;
pub fun (>=) : (x : ddouble, y : ddouble) -> std/core/types/bool;
// Is this `:ddouble` equal to is-zero
pub fun is-zero : (x : ddouble) -> std/core/types/bool;
// Is this a finite `:ddouble`? (i.e. not `is-nan` or `is-inf`)
pub fun is-finite : (x : ddouble) -> std/core/types/bool;
// Is this `:ddouble` negative?
pub fun is-neg : (x : ddouble) -> std/core/types/bool;
pub fun (==) : (x : ddouble, y : ddouble) -> std/core/types/bool;
// Create a `:ddouble` from a `:float64`.
pub fun ddouble : (d : std/core/types/float64) -> ddouble;
fun dquicksum : (x : std/core/types/float64, y : std/core/types/float64) -> ddouble;
// often called `twoproduct` in literature (see [@shewchuk])
fun prod : (x : std/core/types/float64, y : std/core/types/float64) -> edouble;
// Multiply two `:ddouble`s
pub fun (*) : (x : ddouble, y : ddouble) -> ddouble;
// As `sum` but with `x.abs >= y.abs`
fun quicksum : (x : std/core/types/float64, y : std/core/types/float64) -> edouble;
// often called `twosum` in literature (see [@shewchuk])
fun sum : (x : std/core/types/float64, y : std/core/types/float64) -> edouble;
// Add two `:ddouble`s
pub fun (+) : (x : ddouble, y : ddouble) -> ddouble;
// Negate a `:ddouble`.
pub fun (~) : (x : ddouble) -> ddouble;
// Subtract two values.
pub fun (-) : (x : ddouble, y : ddouble) -> ddouble;
// Divide two `:ddouble`s
pub fun (/) : (x : ddouble, y : ddouble) -> ddouble;
// Return the absolute value.
pub fun abs : (x : ddouble) -> ddouble;
// Not-A-Number
pub val dd-nan : ddouble;
val minprecise : std/core/types/int;
fun is-precise : (i : std/core/types/int) -> std/core/types/bool;
fun prodsqr : (x : std/core/types/float64) -> edouble;
// Multiply `x` with itself.
pub fun sqr : (x : ddouble) -> ddouble;
fun npwr-acc : (x : ddouble, acc : ddouble, n : std/core/types/int) -> ddouble;
// One
pub val one : ddouble;
fun npwr : (x : ddouble, n : std/core/types/int) -> ddouble;
// Return `x` to the power of `n`.
fun powi : (x : ddouble, n : std/core/types/int) -> ddouble;
// Ten (`10.ddouble`)
pub val ten : ddouble;
// Return 10 to the power of `exp`.
fun powi10 : (exp : std/core/types/int) -> ddouble;
fun mul-exp10 : (x : ddouble, exp : std/core/types/int) -> ddouble;
fun small-exp : (i : std/core/types/int, e : std/core/types/int) -> ddouble;
fun ddouble-int-exp : (i : std/core/types/int, e : std/core/types/int) -> ddouble;
// Create a `:ddouble` from an `:int`.
// A `:ddouble` can represent integers precisely up to 30 digits.
// If an integer is passed that is out of range an infinity is returned.
pub fun ddouble.1 : (i : std/core/types/int) -> ddouble;
// monadic lift
fun .mlift13469-pddouble-normal : (wild_0 : std/core/types/char) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> std/core/types/int;
// monadic lift
fun .mlift13470-pddouble-normal : (frac : std/core/types/string, neg : std/core/types/bool, whole : std/core/types/string, exp0 : std/core/types/int) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
fun .mlift13471-pddouble-normal : (wild_ : std/core/types/char) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> std/core/types/string;
// monadic lift
fun .mlift13472-pddouble-normal : (neg : std/core/types/bool, whole : std/core/types/string, .y.13442 : std/core/types/string) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
fun .mlift13473-pddouble-normal : (neg : std/core/types/bool, whole : std/core/types/string) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
fun .mlift13474-pddouble-normal : (neg : std/core/types/bool) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
fun pddouble-normal : () -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
fun .mlift13475-pddouble-sum : (hi0 : std/core/types/float64, lo0 : std/core/types/float64) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
fun .mlift13476-pddouble-sum : (hi0 : std/core/types/float64, wild_0 : std/core/types/string) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
fun .mlift13477-pddouble-sum : (hi0 : std/core/types/float64) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
fun pddouble-sum : () -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
pub fun pddouble : () -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
fun .mlift13478-parse-ddouble : (x : ddouble, wild : ()) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
// monadic lift
fun .mlift13479-parse-ddouble : (x : ddouble) -> <(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>> ddouble;
pub fun parse-ddouble : (s : std/core/types/string) -> (std/core/types/maybe :: V -> V)<ddouble>;
// Parse a floating point number with up to 31 digits precision.
// Return `dd-nan` if the string is an invalid number.
pub fun ddouble.2 : (s : std/core/types/string) -> ddouble;
// Decrement by one.
pub fun dec : (x : ddouble) -> ddouble;
// Zero constant
pub val zero : ddouble;
// Return the sum of a list of doubles.
// Uses [Kahan-Babu&scaron;kan-Neumaier summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements)
// to minimize rounding errors. This
// is more precise as Kahan summation and about as fast.\
// `[1.0e3,1.0e97,1.0e3,-1.0e97].sum == 2000.0`\
// A. Neumaier, _Rundungsfehleranalyse einiger Verfahren zur Summation endlicher Summen_.
// Math. Mechanik, 54:39--51, 1974.
pub fun sum.1 : (xs : (std/core/list :: V -> V)<ddouble>) -> ddouble;
// Is this `:ddouble` positive?
pub fun is-pos : (x : ddouble) -> std/core/types/bool;
// Round a `:ddouble` to the nearest integer, rounding to the nearest even number in case of a tie.
pub fun round : (x : ddouble) -> ddouble;
// Remainder of two `:ddouble`s
pub fun (%) : (x : ddouble, y : ddouble) -> ddouble;
pub fun (<) : (x : ddouble, y : ddouble) -> std/core/types/bool;
pub fun (>) : (x : ddouble, y : ddouble) -> std/core/types/bool;
// The maximum of `x` and `y`
pub fun max : (x : ddouble, y : ddouble) -> ddouble;
// The maximum of the absolute values.
fun abs-max : (x : ddouble, y : ddouble) -> ddouble;
// The maximum of a list of absolute values.
fun abs-max.1 : (xs : (std/core/list :: V -> V)<ddouble>) -> ddouble;
// &pi;
pub val dd-pi : ddouble;
// &pi;/2
pub val dd-pi2 : ddouble;
// 3&pi;/4
pub val dd-pi34 : ddouble;
// &pi;/4
pub val dd-pi4 : ddouble;
val ch-factors : (std/core/list :: V -> V)<ddouble>;
// 2&pi;
pub val dd-twopi : ddouble;
// Convert a `:ddouble` to a `:decimal` up to a given precision `prec` (= `-1`).
// A negative precision converts precisely. Returns 0 for non-finite `:ddouble`'s.
pub fun decimal : (x : ddouble, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/num/decimal/decimal;
// Convert a `:ddouble` to the nearest integer (rounding to the nearest even number in case of a tie)
pub fun int : (x : ddouble, nonfin : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/int;
val sin16-table : (std/core/types/vector :: V -> V)<ddouble>;
// Return sin(i*pi/16) for 0 <= i <= 8
fun sin16 : (i : std/core/types/int) -> ddouble;
fun dsum : (x : std/core/types/float64, y : std/core/types/float64) -> ddouble;
// The square root of a non-negative `:ddouble` `x`.
// For negative `x`, `dd-nan` is returned.
pub fun sqrt : (x : ddouble) -> ddouble;
// Calculate sine and cosine on an angle in radians.
pub fun sincos : (rad : ddouble) -> (ddouble, ddouble);
// Return `x` with the sign of `y`.
pub fun with-sign-of : (x : ddouble, y : ddouble) -> ddouble;
// The arc-tangent of a point (`x`,`y`). Returns the angle with respect to the x-axis in radians between -&pi; and &pi;.
pub fun atan2 : (y : ddouble, x : ddouble) -> ddouble;
// The arc-cosine of `x`. Returns the angle in radians.
pub fun acos : (x : ddouble) -> ddouble;
// The _e_ constant.
pub val dd-e : ddouble;
// Negative infinity
pub val dd-neginf : ddouble;
// The 'machine epsilon': this is not well-defined for a `:ddouble` in general since
// the difference between 1.0 and the next representable `:ddouble` value is `dd-true-min`.
// Instead, we take the square of `flt-epsilon`, i.e. 2^-104^.
pub val dd-epsilon : ddouble;
// The natural logarithm of 2
pub val dd-ln2 : ddouble;
// Positive infinity
pub val dd-posinf : ddouble;
fun exp-approx : (p : ddouble, t : ddouble, r : ddouble, eps : std/core/types/float64, fs : (std/core/list :: V -> V)<ddouble>, s : (std/core/types/optional :: V -> V)<ddouble>) -> ddouble;
val exp-factors : (std/core/list :: V -> V)<ddouble>;
// Round to negative infinity.
pub fun floor : (x : ddouble) -> ddouble;
// Multiply `x` by a `:float64` `p` where `p` must be a power of 2.
fun mul-pwr2 : (x : ddouble, p : std/core/types/float64) -> ddouble;
fun half : (x : ddouble) -> ddouble;
// 'Load exponent': returns `x`&middot;2^`exp`^.
pub fun ldexp : (x : ddouble, exp : std/core/types/int) -> ddouble;
fun twice : (x : ddouble) -> ddouble;
// Return _e_ (`dd-e`) to the power of `x`.
pub fun exp : (x : ddouble) -> ddouble;
// Does `x` equal positive infinity?
pub fun is-posinf : (x : ddouble) -> std/core/types/bool;
// The natural logarithm (in base _e_) of `x`.
pub fun ln : (x : ddouble) -> ddouble;
// The area hyperbolic cosine of `x`.
pub fun acosh : (x : ddouble) -> ddouble;
// The arc-sine of `x`. Returns the angle in radians.
pub fun asin : (x : ddouble) -> ddouble;
// The area hyperbolic sine of `x`.
pub fun asinh : (x : ddouble) -> ddouble;
// The arc-tangent of `x`. Returns the angle in radians.
pub fun atan : (x : ddouble) -> ddouble;
// The area hyperbolic tangent of `x`.
pub fun atanh : (x : ddouble) -> ddouble;
// Round to positive infinity.
pub fun ceiling : (x : ddouble) -> ddouble;
// The cosine function of a given angle in radians.
pub fun cos : (rad : ddouble) -> ddouble;
// The hyperbolic sine of `x`.
pub fun sinh : (x : ddouble) -> ddouble;
// The hyperbolic cosine of `x`.
pub fun cosh : (x : ddouble) -> ddouble;
// 8*dd-epsilon
val dd-epsilon8 : ddouble;
// [Euler's constant](https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant)
pub val dd-euler : ddouble;
// The natural logarithm of 10
pub val dd-ln10 : ddouble;
// The base-10 logarithm of _e_.
pub val dd-log10e : ddouble;
// The base-2 logarithm of _e_.
pub val dd-log2e : ddouble;
// The maximum representable `:ddouble`
pub val dd-max : ddouble;
// The smallest positive `:ddouble` that is still normalized
pub val dd-min : ddouble;
// &pi;/16
val dd-pi16 : ddouble;
// `1.0 / sqrt(2.0)`
pub val dd-sqrt12 : ddouble;
// The square-root of 2
pub val dd-sqrt2 : ddouble;
// The smallest positive `:ddouble`  (which is subnormal).
pub val dd-true-min : ddouble;
// Create a `:ddouble` `x` such that `x` equals `d`&middot;10^`e`^.
pub fun ddouble-exp : (d : std/core/types/float64, e : std/core/types/int) -> ddouble;
// Create a `:ddouble` `x` such that `x` equals `i`&middot;10^`e`^.
pub fun ddouble-exp.1 : (i : std/core/types/int, exp : std/core/types/int) -> ddouble;
// Division and remainder of two `:ddouble`s
pub fun divrem : (x : ddouble, y : ddouble) -> (ddouble, ddouble);
// Encode a `:ddouble` `d` from two doubles `(hi,lo)` such that `d` equals  `hi`+`lo`.
pub fun encode : (hi : std/core/types/float64, lo : std/core/types/float64) -> ddouble;
// `x` to the power of `y` both as `:ddouble`
pub fun pow : (x : ddouble, y : ddouble) -> ddouble;
// Return 10 to the power of `exp`.
pub fun exp10 : (exp : ddouble) -> ddouble;
val two : ddouble;
// Return 2 to the power of `exp`.
pub fun exp2 : (exp : ddouble) -> ddouble;
// Return `exp(x - 1.0)`.
// Avoids rounding errors for values of `x` very close to `1.0`.
pub fun expm1 : (x : ddouble) -> ddouble;
fun exp2m1 : (x : ddouble) -> ddouble;
// The _floored_ fraction of `x`. This is always positive, such that `x.floor + x.ffraction == x`.
pub fun ffraction : (x : ddouble) -> ddouble;
// Round towards zero.
pub fun truncate : (x : ddouble) -> ddouble;
// The fraction of `x` such that `x.truncate + x.fraction == x`.
pub fun fraction : (x : ddouble) -> ddouble;
// The minimum of `x` and `y`.
pub fun min : (x : ddouble, y : ddouble) -> ddouble;
// The hypotenuse of `x` and `y`: `sqrt(x*x + y*y)`.
// Prevents overflow for large numbers.
pub fun hypot : (x : ddouble, y : ddouble) -> ddouble;
// The square root of the sum of the squares of three doubles.
// Prevents overflow for large numbers.
pub fun hypot.1 : (x : ddouble, y : ddouble, z : ddouble) -> ddouble;
// The square root of the sum of squares of a list of doubles.
// Prevents overflow for large numbers and uses Kahan-Babu&scaron;kan-Neumaier summation
// for precision.
pub fun hypot.2 : (xs : (std/core/list :: V -> V)<ddouble>) -> ddouble;
// Increment by one.
pub fun inc : (x : ddouble) -> ddouble;
// Is this an infinite value.
pub fun is-inf : (x : ddouble) -> std/core/types/bool;
// Is this `:ddouble` not-a-number?
pub fun is-nan : (x : ddouble) -> std/core/types/bool;
// Does `x` equal negative infinity?
pub fun is-neginf : (x : ddouble) -> std/core/types/bool;
// Return the sign of the `:ddouble`.
pub fun is-sign : (x : ddouble) -> std/core/types/order;
// Return `ln(1.0 + x)`.
// Avoids potential imprecision for small `x` where adding `1.0` explicitly
// may lead to rounding errors.
pub fun ln1p : (x : ddouble) -> ddouble;
// Returns `ln(exp(x) + exp(y))`.
// Avoids overlow/underflow errors.
pub fun lnaddexp : (x : ddouble, y : ddouble) -> ddouble;
// Return the logarithm in some base `b` of a `:ddouble` `x`
pub fun log : (x : ddouble, base : ddouble) -> ddouble;
// The logarithm in base 10 of `x`.
pub fun log10 : (x : ddouble) -> ddouble;
// The logarithm in base 2 of `x`.
pub fun log2 : (x : ddouble) -> ddouble;
fun log2p1 : (x : ddouble) -> ddouble;
// Returns `log2( exp2(x) + exp2(y) )`.
// Avoids overlow/underflow errors.
pub fun logaddexp2 : (x : ddouble, y : ddouble) -> ddouble;
// Return if two `:ddouble`s are nearly equal with respect to some `epsilon` (=`8*dd-epsilon`).
// The epsilon is the nearest difference for numbers around 1.0. The routine automatically
// scales the epsilon for larger and smaller numbers, and for numbers close to zero.
pub fun nearly-eq : (x : ddouble, y : ddouble, epsilon : (std/core/types/optional :: V -> V)<ddouble>) -> std/core/types/bool;
// The `n`-th root of a `:ddouble` number `x`.
// `n` must be positive, and if `n` is even, then
// `x` must not be negative.
pub fun nroot : (x : ddouble, n : std/core/types/int) -> ddouble;
val one-half : ddouble;
// Round a `:ddouble` to a specified precision.
// Uses `round` if the precision is smaller or equal to zero.
pub fun round-to-prec : (x : ddouble, prec : std/core/types/int) -> ddouble;
// Show a `:ddouble` `x` with a given precision `prec` (=`-31`).
// The precision specifies the  number of digits after the dot (in either scientific of fixed-point notation).
// If the precision is negative, _at most_ `prec` digits are displayed, while for a positive
// precision, exactly `prec` digits behind the dot are displayed.
// This uses `show-fixed` when the exponent of `x` in scientific notation is larger than -5
// and smaller than the precision (or 15 in case of a negative precision), otherwise it uses `show-exp`.
pub fun show : (x : ddouble, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
/* Show a ddouble `x` with a given precision `prec` (=`-31`) in scientific notation.
The precision specifies the  number of digits after the dot, i.e.
the number of significant digits is `prec+1`.
If the precision is negative, _at most_ `prec` digits are displayed, and if
it is positive exactly `prec` digits are used.
```
> 1.1.ddouble.show-exp
"1.1000000000000000888178419700125"
> 1.1.ddouble.show-exp(-100)
"1.100000000000000088817841970012523233890533447265625"
> 1.1.ddouble.show-exp(5)
"1.10000"
> 1.1.ddouble.show-exp(-5)
"1.1"
```
.
*/
pub fun show-exp : (x : ddouble, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
/* Show a ddouble `x` with a given precision `prec` (=`-31`) in fixed-point notation.
The precision specifies the  number of digits after the dot.
If the precision is negative, _at most_  `prec` digits after the dot are displayed,
while for a positive precision, exactly `prec` digits are used.
```
> 0.1.ddouble.show-fixed
"0.1000000000000000055511151231258"
> 0.1.ddouble.show-fixed(-100)
"0.1000000000000000055511151231257827021181583404541015625"
> 0.1.ddouble.show-fixed(5)
"0.10000"
> 0.1.ddouble.show-fixed(-5)
"0.1"
```
.
*/
pub fun show-fixed : (x : ddouble, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
/* Show a `:ddouble` `x` precisely as the sum of two `:float64`s
in [hexadecimal notation](https://books.google.com/books?id=FgMsCwAAQBAJ&pg=PA41).
Use this if you need to guarantee that you can parse back `:ddouble`s exactly,
i.e. `x == x.show-hex.ddouble`.
```
> 0.1.ddouble.show-hex
"0x1.999999999999Ap-4 + 0x0.0p+0"
> "0.1".ddouble.show-hex
"0x1.999999999999Ap-4 + -0x1.999999999999Ap-58"
> dd-pi.show-hex
"0x1.921FB54442D18p+1 + 0x1.1A62633145C07p-53"
> dd-max.show-hex
"0x1.FFFFFFFFFFFFFp+1023 + 0x1.FFFFFFFFFFFFFp+969"
```
.
*/
pub fun show-hex : (x : ddouble, width : (std/core/types/optional :: V -> V)<std/core/types/int>, use-capitals : (std/core/types/optional :: V -> V)<std/core/types/bool>, pre : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Show a `:ddouble` as the sum of  `:float64`s with an optional precision.
// Note: use `show-hex` for reliable round-trip parsing.
pub fun show-sum : (x : ddouble, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// The sine function of a given angle in radians.
pub fun sin : (rad : ddouble) -> ddouble;
// The tangent of a given angle in radians.
pub fun tan : (rad : ddouble) -> ddouble;
// The hyperbolic tangent of `x`.
pub fun tanh : (x : ddouble) -> ddouble;
// Return if two `:ddouble`s are nearly equal with respect to an `epsilon` of `10*dd-epsilon`.
// See also `nearly-eq` which takes an explicit `epsilon`.
pub fun (~=) : (x : ddouble, y : ddouble) -> std/core/types/bool;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^" fun hi // inline size: 0
  = fn(ddouble0: ddouble){
    match (ddouble0) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
         -> .x;
    };
  };
inline borrow "^" fun lo // inline size: 0
  = fn(ddouble0: ddouble){
    match (ddouble0) {
      ((.skip std/num/ddouble/Ddouble((.pat0: std/core/types/float64) : std/core/types/float64, (.x: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
         -> .x;
    };
  };
fun .copy // inline size: 3
  = fn(.this: ddouble, hi0: (std/core/types/optional :: V -> V)<std/core/types/float64>, lo0: (std/core/types/optional :: V -> V)<std/core/types/float64>){
    std/num/ddouble/Ddouble((match (hi0) {
        ((std/core/types/Optional((.hi.180: std/core/types/float64) : std/core/types/float64) : (std/core/types/optional :: V -> V)<std/core/types/float64> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/float64>))
           -> .hi.180;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/float64> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/float64>))
           -> (match (.this) {
            ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat00: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
               -> .x;
          });
      }), (match (lo0) {
        ((std/core/types/Optional((.lo.186: std/core/types/float64) : std/core/types/float64) : (std/core/types/optional :: V -> V)<std/core/types/float64> ) as .pat10: ((std/core/types/optional :: V -> V)<std/core/types/float64>))
           -> .lo.186;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/float64> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/float64>))
           -> (match (.this) {
            ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat3: ddouble)
               -> .x0;
          });
      }));
  };
inline borrow "^" fun num // inline size: 0
  = fn(edouble: edouble){
    match (edouble) {
      ((.skip std/num/ddouble/Edouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : edouble ) as .pat: edouble)
         -> .x;
    };
  };
inline borrow "^" fun err // inline size: 0
  = fn(edouble: edouble){
    match (edouble) {
      ((.skip std/num/ddouble/Edouble((.pat0: std/core/types/float64) : std/core/types/float64, (.x: std/core/types/float64) : std/core/types/float64) : edouble ) as .pat: edouble)
         -> .x;
    };
  };
fun .copy.1 // inline size: 3
  = fn(.this: edouble, num0: (std/core/types/optional :: V -> V)<std/core/types/float64>, err0: (std/core/types/optional :: V -> V)<std/core/types/float64>){
    std/num/ddouble/Edouble((match (num0) {
        ((std/core/types/Optional((.num.212: std/core/types/float64) : std/core/types/float64) : (std/core/types/optional :: V -> V)<std/core/types/float64> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/float64>))
           -> .num.212;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/float64> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/float64>))
           -> (match (.this) {
            ((.skip std/num/ddouble/Edouble((.x: std/core/types/float64) : std/core/types/float64, (.pat00: std/core/types/float64) : std/core/types/float64) : edouble ) as .pat1: edouble)
               -> .x;
          });
      }), (match (err0) {
        ((std/core/types/Optional((.err.218: std/core/types/float64) : std/core/types/float64) : (std/core/types/optional :: V -> V)<std/core/types/float64> ) as .pat10: ((std/core/types/optional :: V -> V)<std/core/types/float64>))
           -> .err.218;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/float64> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/float64>))
           -> (match (.this) {
            ((.skip std/num/ddouble/Edouble((.pat01: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : edouble ) as .pat3: edouble)
               -> .x0;
          });
      }));
  };
inline val maxprecise // inline size: 0
  = 9007199254740991;
inline fun float64 // inline size: 0
  = fn(x: ddouble){
    match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
         -> .x;
    };
  };
inline val dd-default-prec // inline size: 0
  = -31;
inline val dd-max-prec // inline size: 0
  = 31;
fun decode // inline size: 1
  = fn(d: ddouble){
    std/core/types/(,)<std/core/types/float64,std/core/types/float64>((match (d) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
           -> .x;
      }), (match (d) {
        ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
           -> .x0;
      }));
  };
fun compare // inline size: 3
  = fn(x: ddouble, y: ddouble){
    match ((std/num/float64/compare((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
           -> .x;
      }), (match (y) {
        ((.skip std/num/ddouble/Ddouble((.x0: std/core/types/float64) : std/core/types/float64, (.pat00: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
           -> .x0;
      })))) {
      ((std/core/types/Eq() : std/core/types/order ) as .pat2: std/core/types/order)
         -> std/num/float64/compare((match (x) {
            ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/float64) : std/core/types/float64, (.x1: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat3: ddouble)
               -> .x1;
          }), (match (y) {
            ((.skip std/num/ddouble/Ddouble((.pat02: std/core/types/float64) : std/core/types/float64, (.x2: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat4: ddouble)
               -> .x2;
          }));
      (ord: std/core/types/order)
         -> ord;
    };
  };
fun (!=) // inline size: 4
  = fn(x: ddouble, y: ddouble){
    std/core/(!=.4)((match ((std/num/float64/compare((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }), (match (y) {
          ((.skip std/num/ddouble/Ddouble((.x0: std/core/types/float64) : std/core/types/float64, (.pat00: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        })))) {
        ((std/core/types/Eq() : std/core/types/order ) as .pat2: std/core/types/order)
           -> std/num/float64/compare((match (x) {
              ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/float64) : std/core/types/float64, (.x1: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat3: ddouble)
                 -> .x1;
            }), (match (y) {
              ((.skip std/num/ddouble/Ddouble((.pat02: std/core/types/float64) : std/core/types/float64, (.x2: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat4: ddouble)
                 -> .x2;
            }));
        (ord: std/core/types/order)
           -> ord;
      }), std/core/types/Eq);
  };
fun (<=) // inline size: 4
  = fn(x: ddouble, y: ddouble){
    std/core/(!=.4)((match ((std/num/float64/compare((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }), (match (y) {
          ((.skip std/num/ddouble/Ddouble((.x0: std/core/types/float64) : std/core/types/float64, (.pat00: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        })))) {
        ((std/core/types/Eq() : std/core/types/order ) as .pat2: std/core/types/order)
           -> std/num/float64/compare((match (x) {
              ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/float64) : std/core/types/float64, (.x1: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat3: ddouble)
                 -> .x1;
            }), (match (y) {
              ((.skip std/num/ddouble/Ddouble((.pat02: std/core/types/float64) : std/core/types/float64, (.x2: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat4: ddouble)
                 -> .x2;
            }));
        (ord: std/core/types/order)
           -> ord;
      }), std/core/types/Gt);
  };
fun (>=) // inline size: 4
  = fn(x: ddouble, y: ddouble){
    std/core/(!=.4)((match ((std/num/float64/compare((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }), (match (y) {
          ((.skip std/num/ddouble/Ddouble((.x0: std/core/types/float64) : std/core/types/float64, (.pat00: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        })))) {
        ((std/core/types/Eq() : std/core/types/order ) as .pat2: std/core/types/order)
           -> std/num/float64/compare((match (x) {
              ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/float64) : std/core/types/float64, (.x1: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat3: ddouble)
                 -> .x1;
            }), (match (y) {
              ((.skip std/num/ddouble/Ddouble((.pat02: std/core/types/float64) : std/core/types/float64, (.x2: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat4: ddouble)
                 -> .x2;
            }));
        (ord: std/core/types/order)
           -> ord;
      }), std/core/types/Lt);
  };
fun is-zero // inline size: 1
  = fn(x: ddouble){
    std/core/(==.2)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
           -> .x;
      }), 0.0);
  };
fun is-finite // inline size: 3
  = fn(x: ddouble){
    match ((std/num/float64/is-finite((match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
         -> .x;
    })))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/num/float64/is-finite((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat2: ddouble)
             -> .x0;
        }));
      (.pat01: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun is-neg // inline size: 1
  = fn(x: ddouble){
    std/core/(<.4)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
           -> .x;
      }), 0.0);
  };
fun (==) // inline size: 4
  = fn(x: ddouble, y: ddouble){
    std/core/(==.4)((match ((std/num/float64/compare((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }), (match (y) {
          ((.skip std/num/ddouble/Ddouble((.x0: std/core/types/float64) : std/core/types/float64, (.pat00: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        })))) {
        ((std/core/types/Eq() : std/core/types/order ) as .pat2: std/core/types/order)
           -> std/num/float64/compare((match (x) {
              ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/float64) : std/core/types/float64, (.x1: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat3: ddouble)
                 -> .x1;
            }), (match (y) {
              ((.skip std/num/ddouble/Ddouble((.pat02: std/core/types/float64) : std/core/types/float64, (.x2: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat4: ddouble)
                 -> .x2;
            }));
        (ord: std/core/types/order)
           -> ord;
      }), std/core/types/Eq);
  };
fun ddouble // inline size: 1
  = fn(d: std/core/types/float64){
    std/num/ddouble/Ddouble(d, 0.0);
  };
fun prod // inline size: 4
  = fn(x: std/core/types/float64, y: std/core/types/float64){
    val z : std/core/types/float64
      = std/core/(*.1)(x, y);
    val err0 : std/core/types/float64
      = std/num/float64/fmadd(x, y, (std/core/(~.1)(z)));
    std/num/ddouble/Edouble(z, err0);
  };
fun (~) // inline size: 3
  = fn(x: ddouble){
    std/num/ddouble/Ddouble((std/core/(~.1)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
           -> .x;
      }))), (std/core/(~.1)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
           -> .x0;
      }))));
  };
fun (-) // inline size: 4
  = fn(x: ddouble, y: ddouble){
    std/num/ddouble/(+)(x, (std/num/ddouble/Ddouble((std/core/(~.1)((match (y) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }))), (std/core/(~.1)((match (y) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        }))))));
  };
fun is-precise // inline size: 3
  = fn(i: std/core/types/int){
    match ((std/core/(>=.1)(i, std/num/ddouble/minprecise))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/(<=.1)(i, 9007199254740991);
      (.pat0: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun prodsqr // inline size: 4
  = fn(x: std/core/types/float64){
    val z : std/core/types/float64
      = std/core/(*.1)(x, x);
    val err0 : std/core/types/float64
      = std/num/float64/fmadd(x, x, (std/core/(~.1)(z)));
    std/num/ddouble/Edouble(z, err0);
  };
fun powi10 // inline size: 1
  = fn(exp0: std/core/types/int){
    std/num/ddouble/powi(std/num/ddouble/ten, exp0);
  };
fun mul-exp10 // inline size: 4
  = fn(x: ddouble, exp0: std/core/types/int){
    match ((std/core/is-zero(exp0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> x;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/num/ddouble/(*)(x, (std/num/ddouble/powi(std/num/ddouble/ten, exp0)));
    };
  };
fun ddouble.1 // inline size: 1
  = fn(i: std/core/types/int){
    std/num/ddouble/ddouble-int-exp(i, 0);
  };
fun pddouble // inline size: 1
  = fn<<(std/core/types/handled :: HX -> X)<(std/text/parse/parse :: HX)>>>(){
    std/text/parse/(||)<ddouble,(std/core/types/(<>) :: E)>(std/num/ddouble/pddouble-sum, std/num/ddouble/pddouble-normal);
  };
fun ddouble.2 // inline size: 2
  = fn(s: std/core/types/string){
    val m.12810 : (std/core/types/maybe :: V -> V)<ddouble>
          = std/num/ddouble/parse-ddouble(s);
    match (m.12810) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<ddouble> ) as .pat: ((std/core/types/maybe :: V -> V)<ddouble>))
         -> std/num/ddouble/dd-nan;
      ((.skip std/core/types/Just((x: ddouble) : ddouble) : (std/core/types/maybe :: V -> V)<ddouble> ) as .pat0: ((std/core/types/maybe :: V -> V)<ddouble>))
         -> x;
    };
  };
fun dec // inline size: 4
  = fn(x: ddouble){
    std/num/ddouble/(+)(x, (std/num/ddouble/Ddouble((std/core/(~.1)((match (std/num/ddouble/one) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }))), (std/core/(~.1)((match (std/num/ddouble/one) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        }))))));
  };
fun is-pos // inline size: 1
  = fn(x: ddouble){
    std/core/(>.2)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
           -> .x;
      }), 0.0);
  };
fun (<) // inline size: 4
  = fn(x: ddouble, y: ddouble){
    std/core/(==.4)((match ((std/num/float64/compare((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }), (match (y) {
          ((.skip std/num/ddouble/Ddouble((.x0: std/core/types/float64) : std/core/types/float64, (.pat00: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        })))) {
        ((std/core/types/Eq() : std/core/types/order ) as .pat2: std/core/types/order)
           -> std/num/float64/compare((match (x) {
              ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/float64) : std/core/types/float64, (.x1: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat3: ddouble)
                 -> .x1;
            }), (match (y) {
              ((.skip std/num/ddouble/Ddouble((.pat02: std/core/types/float64) : std/core/types/float64, (.x2: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat4: ddouble)
                 -> .x2;
            }));
        (ord: std/core/types/order)
           -> ord;
      }), std/core/types/Lt);
  };
fun (>) // inline size: 4
  = fn(x: ddouble, y: ddouble){
    std/core/(==.4)((match ((std/num/float64/compare((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }), (match (y) {
          ((.skip std/num/ddouble/Ddouble((.x0: std/core/types/float64) : std/core/types/float64, (.pat00: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        })))) {
        ((std/core/types/Eq() : std/core/types/order ) as .pat2: std/core/types/order)
           -> std/num/float64/compare((match (x) {
              ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/float64) : std/core/types/float64, (.x1: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat3: ddouble)
                 -> .x1;
            }), (match (y) {
              ((.skip std/num/ddouble/Ddouble((.pat02: std/core/types/float64) : std/core/types/float64, (.x2: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat4: ddouble)
                 -> .x2;
            }));
        (ord: std/core/types/order)
           -> ord;
      }), std/core/types/Gt);
  };
fun sin16 // inline size: 2
  = fn(i: std/core/types/int){
    val m.12857 : (std/core/types/maybe :: V -> V)<ddouble>
          = std/core/at<ddouble>(std/num/ddouble/sin16-table, i);
    match (m.12857) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<ddouble> ) as .pat: ((std/core/types/maybe :: V -> V)<ddouble>))
         -> std/num/ddouble/dd-nan;
      ((.skip std/core/types/Just((x: ddouble) : ddouble) : (std/core/types/maybe :: V -> V)<ddouble> ) as .pat0: ((std/core/types/maybe :: V -> V)<ddouble>))
         -> x;
    };
  };
fun mul-pwr2 // inline size: 3
  = fn(x: ddouble, p: std/core/types/float64){
    std/num/ddouble/Ddouble((std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }), p)), (std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        }), p)));
  };
fun half // inline size: 3
  = fn(x: ddouble){
    std/num/ddouble/Ddouble((std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }), 0.5)), (std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        }), 0.5)));
  };
fun ldexp // inline size: 3
  = fn(x: ddouble, exp0: std/core/types/int){
    std/num/ddouble/Ddouble((std/num/float64/ldexp((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }), exp0)), (std/num/float64/ldexp((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        }), exp0)));
  };
fun twice // inline size: 3
  = fn(x: ddouble){
    std/num/ddouble/Ddouble((std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
             -> .x;
        }), 2.0)), (std/core/(*.1)((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat00: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat1: ddouble)
             -> .x0;
        }), 2.0)));
  };
fun is-posinf // inline size: 1
  = fn(x: ddouble){
    std/num/float64/is-posinf((match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
         -> .x;
    }));
  };
fun atan // inline size: 1
  = fn(x: ddouble){
    std/num/ddouble/atan2(x, std/num/ddouble/one);
  };
fun cos // inline size: 1
  = fn(rad: ddouble){
    val .this.13054 : (ddouble, ddouble)
          = std/num/ddouble/sincos(rad);
    match (.this.13054) {
      ((.skip std/core/types/(,)((.pat0: ddouble) : ddouble, (.x: ddouble) : ddouble) : (ddouble, ddouble) ) as .pat: (ddouble, ddouble))
         -> .x;
    };
  };
fun encode // inline size: 3
  = fn(hi0: std/core/types/float64, lo0: std/core/types/float64){
    std/num/ddouble/(+)((std/num/ddouble/Ddouble(hi0, 0.0)), (std/num/ddouble/Ddouble(lo0, 0.0)));
  };
fun pow // inline size: 3
  = fn(x: ddouble, y: ddouble){
    std/num/ddouble/exp((std/num/ddouble/(*)(y, (std/num/ddouble/ln(x)))));
  };
fun exp10 // inline size: 3
  = fn(exp0: ddouble){
    std/num/ddouble/exp((std/num/ddouble/(*)(exp0, (std/num/ddouble/ln(std/num/ddouble/ten)))));
  };
fun exp2 // inline size: 3
  = fn(exp0: ddouble){
    std/num/ddouble/exp((std/num/ddouble/(*)(exp0, (std/num/ddouble/ln(std/num/ddouble/two)))));
  };
fun exp2m1 // inline size: 2
  = fn(x: ddouble){
    std/num/ddouble/expm1((std/num/ddouble/(*)(std/num/ddouble/dd-ln2, x)));
  };
fun truncate // inline size: 4
  = fn(x: ddouble){
    match ((std/core/(<.4)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
           -> .x;
      }), 0.0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/num/ddouble/ceiling(x);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
         -> std/num/ddouble/floor(x);
    };
  };
fun inc // inline size: 1
  = fn(x: ddouble){
    std/num/ddouble/(+)(x, std/num/ddouble/one);
  };
fun is-inf // inline size: 1
  = fn(x: ddouble){
    std/num/float64/is-inf((match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
         -> .x;
    }));
  };
fun is-nan // inline size: 3
  = fn(x: ddouble){
    match ((std/num/float64/is-nan((match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
         -> .x;
    })))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/core/types/True;
      (.pat00: std/core/types/bool)
         -> std/num/float64/is-nan((match (x) {
          ((.skip std/num/ddouble/Ddouble((.pat01: std/core/types/float64) : std/core/types/float64, (.x0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat2: ddouble)
             -> .x0;
        }));
    };
  };
fun is-neginf // inline size: 1
  = fn(x: ddouble){
    std/num/float64/is-neginf((match (x) {
      ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
         -> .x;
    }));
  };
fun is-sign // inline size: 4
  = fn(x: ddouble){
    match ((std/core/(==.2)((match (x) {
        ((.skip std/num/ddouble/Ddouble((.x: std/core/types/float64) : std/core/types/float64, (.pat0: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat: ddouble)
           -> .x;
      }), 0.0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/core/types/Eq;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
         -> (match ((std/core/(<.4)((match (x) {
            ((.skip std/num/ddouble/Ddouble((.x0: std/core/types/float64) : std/core/types/float64, (.pat01: std/core/types/float64) : std/core/types/float64) : ddouble ) as .pat2: ddouble)
               -> .x0;
          }), 0.0))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat10: std/core/types/bool)
             -> std/core/types/Lt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat20: std/core/types/bool)
             -> std/core/types/Gt;
        });
    };
  };
fun log // inline size: 3
  = fn(x: ddouble, base: ddouble){
    std/num/ddouble/(/)((std/num/ddouble/ln(x)), (std/num/ddouble/ln(base)));
  };
fun log10 // inline size: 2
  = fn(x: ddouble){
    std/num/ddouble/(/)((std/num/ddouble/ln(x)), std/num/ddouble/dd-ln10);
  };
fun log2 // inline size: 2
  = fn(x: ddouble){
    std/num/ddouble/(/)((std/num/ddouble/ln(x)), std/num/ddouble/dd-ln2);
  };
fun log2p1 // inline size: 2
  = fn(x: ddouble){
    std/num/ddouble/(*)(std/num/ddouble/dd-log2e, (std/num/ddouble/ln1p(x)));
  };
fun sin // inline size: 1
  = fn(rad: ddouble){
    val .this.13242 : (ddouble, ddouble)
          = std/num/ddouble/sincos(rad);
    match (.this.13242) {
      ((.skip std/core/types/(,)((.x: ddouble) : ddouble, (.pat0: ddouble) : ddouble) : (ddouble, ddouble) ) as .pat: (ddouble, ddouble))
         -> .x;
    };
  };
fun tan // inline size: 2
  = fn(rad: ddouble){
    match ((std/num/ddouble/sincos(rad))) {
      ((.skip std/core/types/(,)(((.skip std/num/ddouble/Ddouble((.pat0: std/core/types/float64) : std/core/types/float64, (.pat1: std/core/types/float64) : std/core/types/float64) : ddouble ) as s: ddouble) : ddouble, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/float64) : std/core/types/float64, (.pat3: std/core/types/float64) : std/core/types/float64) : ddouble ) as c: ddouble) : ddouble) : (ddouble, ddouble) ) as .pat: (ddouble, ddouble))
         -> std/num/ddouble/(/)(s, c);
    };
  };
fun (~=) // inline size: 1
  = fn(x: ddouble, y: ddouble){
    std/num/ddouble/nearly-eq(x, y, (std/core/types/None<ddouble>));
  };