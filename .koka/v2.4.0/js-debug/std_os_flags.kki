/* Parsing of command line flags.

For example:

```
struct myflags(
  verbose : bool = False,
  version : bool = False, 
  name : string = "",
  output : string = "",
  arguments : list<string> = []
)

val myflags : list<flag<myflags>>
  = [ Flag( "V?", ["version"], Bool(set-version),     "display version information" ),
      Flag( "v",  ["verbose"], Bool(set-verbose),     "verbosely list files"),
      Flag( "o",  ["output"],  Opt(set-output,"FILE"),"use FILE for dump" ),
      Flag( "n",  ["name"],    Req(set-name,"USER"),  "only show USER files" ),
    ]

fun set-name( t : myflags, name )  { t(name = name)
fun set-verbose( t : myflags, v )  { t(verbose = v)
fun set-version( t : myflags, v )  { t(version = v)
fun set-output( t : myflags, mbs : maybe<string> ) : myflags

  match(mbs)
    Nothing -> t(output = "stdout")
    Just(s) -> t(output = s)


pub fun test( cmdargs )

  val header = "usage:\n program [options] files\n\noptions:"
  // testflags.usageInfo( header ).println
  val (flags,args,errs) = parse( Myflags(), myflags, cmdargs )
  if (errs.is-nil)
    println( "\nsuccess!" );
    println( "flags: " ++ flags.show-flags)
    println( "arguments: " ++ args.join(" ") );
    if (flags.version) myflags.usage(header).println

  else
    println( errs.join("\n") ++ "\n" ++ myflags.usage(header) )


fun show-flags( o : myflags )
  "{" ++ ["verbose=" ++ o.verbose.show,
         "version=" ++ o.version.show,
         "name=" ++ o.name.show,
         "output=" ++ o.output.show,
         "arguments=" ++ o.arguments.join(",")].join(";") ++ "}"

```
\/
*/
module interface std/os/flags
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core/hnd = std/core/hnd = "";
import std/core = std/core = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// An alias for the empty effect.
local alias std/core/total :: E = (std/core/types/(<>) :: E) = 1;
 
//------------------------------
//#kki: type declarations
 
// Specifies the argument of an flag
pub value{0,2} type flag-parser <a> :: V -> V {
  // For a flag `foo` Automatically enables forms `--no-foo` and `--foo=true|false`.
  pub con Bool(default: (a, std/core/types/bool) -> a) : forall<a> (default : (a, std/core/types/bool) -> a) -> (flag-parser :: V -> V)<a>;
  // A required argument.
  pub con Req(parse: (a, std/core/types/string) -> a, help: std/core/types/string) : forall<a> (parse : (a, std/core/types/string) -> a, help : std/core/types/string) -> (flag-parser :: V -> V)<a>;
  // An flagal argument.
  pub con Opt(parse: (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, help: std/core/types/string) : forall<a> (parse : (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, help : std/core/types/string) -> (flag-parser :: V -> V)<a>;
};
// Specifies a single command line flag
// For example: `flag("h?",["help"],Bool(Help),"show help information")`.
pub type flag <a> :: V -> V {
  // Specifies a single command line flag
// For example: `flag("h?",["help"],Bool(Help),"show help information")`.
  pub con Flag(short-names: std/core/types/string, long-names: (std/core/list :: V -> V)<std/core/types/string>, parser: (flag-parser :: V -> V)<a>, help: std/core/types/string) : forall<a> (short-names : std/core/types/string, long-names : (std/core/list :: V -> V)<std/core/types/string>, parser : (flag-parser :: V -> V)<a>, help : std/core/types/string) -> (flag :: V -> V)<a>;
};
value{0,1} type flag-kind <a> :: V -> V {
  con Flg(set: (a) -> a) : forall<a> (set : (a) -> a) -> (flag-kind :: V -> V)<a>;
  con Arg(arg: std/core/types/string) : forall<a> (arg : std/core/types/string) -> (flag-kind :: V -> V)<a>;
  con End : forall<a> (flag-kind :: V -> V)<a>;
  con Unknown(arg: std/core/types/string) : forall<a> (arg : std/core/types/string) -> (flag-kind :: V -> V)<a>;
  con Error(msg: std/core/types/string) : forall<a> (msg : std/core/types/string) -> (flag-kind :: V -> V)<a>;
};
// Specifies how to handle flags that follow non-flag command line arguments.
pub value{0,1} type flag-order <a> :: V -> V {
  // Allow flags to be permuted with non-flag arguments (default)
  pub con Permute : forall<a> (flag-order :: V -> V)<a>;
  // flags following non-flag arguments are treated as arguments
  pub con Preorder : forall<a> (flag-order :: V -> V)<a>;
  // Wrap each non-flag argument into an flag
  pub con Wrap(wrap: (std/core/types/string) -> a) : forall<a> (wrap : (std/core/types/string) -> a) -> (flag-order :: V -> V)<a>;
};
type myflags {
  con Myflags(verbose: std/core/types/bool, version: std/core/types/bool, name: std/core/types/string, output: std/core/types/string, arguments: (std/core/list :: V -> V)<std/core/types/string>) : (verbose : std/core/types/bool, version : std/core/types/bool, name : std/core/types/string, output : std/core/types/string, arguments : (std/core/list :: V -> V)<std/core/types/string>) -> myflags;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Tests for the `Bool` constructor of the `:flag-parser` type.
pub fun is-bool : forall<a> (^ flag-parser : (flag-parser :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Req` constructor of the `:flag-parser` type.
pub fun is-req : forall<a> (^ flag-parser : (flag-parser :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Opt` constructor of the `:flag-parser` type.
pub fun is-opt : forall<a> (^ flag-parser : (flag-parser :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Retrieves the `short-names` constructor field of the `:flag` type.
pub fun short-names : forall<a> (^ flag : (flag :: V -> V)<a>) -> std/core/types/string;
// Automatically generated. Retrieves the `long-names` constructor field of the `:flag` type.
pub fun long-names : forall<a> (^ flag : (flag :: V -> V)<a>) -> (std/core/list :: V -> V)<std/core/types/string>;
// Automatically generated. Retrieves the `parser` constructor field of the `:flag` type.
pub fun parser : forall<a> (^ flag : (flag :: V -> V)<a>) -> (flag-parser :: V -> V)<a>;
// Automatically generated. Retrieves the `help` constructor field of the `:flag` type.
pub fun help : forall<a> (^ flag : (flag :: V -> V)<a>) -> std/core/types/string;
pub fun .copy : forall<a> (.this : (flag :: V -> V)<a>, short-names : (std/core/types/optional :: V -> V)<std/core/types/string>, long-names : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>, parser : (std/core/types/optional :: V -> V)<(flag-parser :: V -> V)<a>>, help : (std/core/types/optional :: V -> V)<std/core/types/string>) -> (flag :: V -> V)<a>;
// Automatically generated. Tests for the `Flg` constructor of the `:flag-kind` type.
fun is-flg : forall<a> (^ flag-kind : (flag-kind :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Arg` constructor of the `:flag-kind` type.
fun is-arg : forall<a> (^ flag-kind : (flag-kind :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `End` constructor of the `:flag-kind` type.
fun is-end : forall<a> (^ flag-kind : (flag-kind :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Unknown` constructor of the `:flag-kind` type.
fun is-unknown : forall<a> (^ flag-kind : (flag-kind :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Error` constructor of the `:flag-kind` type.
fun is-error : forall<a> (^ flag-kind : (flag-kind :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Permute` constructor of the `:flag-order` type.
pub fun is-permute : forall<a> (^ flag-order : (flag-order :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Preorder` constructor of the `:flag-order` type.
pub fun is-preorder : forall<a> (^ flag-order : (flag-order :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Wrap` constructor of the `:flag-order` type.
pub fun is-wrap : forall<a> (^ flag-order : (flag-order :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Retrieves the `verbose` constructor field of the `:myflags` type.
fun verbose : (^ myflags : myflags) -> std/core/types/bool;
// Automatically generated. Retrieves the `version` constructor field of the `:myflags` type.
fun version : (^ myflags : myflags) -> std/core/types/bool;
// Automatically generated. Retrieves the `name` constructor field of the `:myflags` type.
fun name : (^ myflags : myflags) -> std/core/types/string;
// Automatically generated. Retrieves the `output` constructor field of the `:myflags` type.
fun output : (^ myflags : myflags) -> std/core/types/string;
// Automatically generated. Retrieves the `arguments` constructor field of the `:myflags` type.
fun arguments : (^ myflags : myflags) -> (std/core/list :: V -> V)<std/core/types/string>;
fun .copy.1 : (.this : myflags, verbose : (std/core/types/optional :: V -> V)<std/core/types/bool>, version : (std/core/types/optional :: V -> V)<std/core/types/bool>, name : (std/core/types/optional :: V -> V)<std/core/types/string>, output : (std/core/types/optional :: V -> V)<std/core/types/string>, arguments : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>) -> myflags;
fun set-name : (t : myflags, name : std/core/types/string) -> myflags;
fun set-output : (t : myflags, mbs : (std/core/types/maybe :: V -> V)<std/core/types/string>) -> myflags;
fun set-verbose : (t : myflags, v : std/core/types/bool) -> myflags;
fun set-version : (t : myflags, v : std/core/types/bool) -> myflags;
fun break : (s : std/core/types/string, c : std/core/types/string) -> (std/core/types/string, std/core/types/string);
fun show-long-flag : forall<a> (parser : (flag-parser :: V -> V)<a>) -> std/core/types/string;
fun show-short-flag : forall<a> (parser : (flag-parser :: V -> V)<a>) -> std/core/types/string;
// lifted local: unzip3, iter
fun .lift5759-unzip3 : forall<a,b,c> (ys : (std/core/list :: V -> V)<(a, b, c)>, acc1 : (std/core/list :: V -> V)<a>, acc2 : (std/core/list :: V -> V)<b>, acc3 : (std/core/list :: V -> V)<c>) -> ((std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<b>, (std/core/list :: V -> V)<c>);
// Unzip a list of triples into three lists
fun unzip3 : forall<a,b,c> (xs : (std/core/list :: V -> V)<(a, b, c)>) -> ((std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<b>, (std/core/list :: V -> V)<c>);
fun error-negate : forall<a> (flagname : std/core/types/string) -> (flag-kind :: V -> V)<a>;
fun error-noarg : forall<a> (opt : std/core/types/string) -> (flag-kind :: V -> V)<a>;
fun error-required : forall<a> (help : std/core/types/string, opt : std/core/types/string) -> (flag-kind :: V -> V)<a>;
fun error-unknown-message : (opt : std/core/types/string) -> std/core/types/string;
fun show-flags : (o : myflags) -> std/core/types/string;
val myflags : (std/core/list :: V -> V)<(flag :: V -> V)<myflags>>;
fun .create-Myflags : (verbose : (std/core/types/optional :: V -> V)<std/core/types/bool>, version : (std/core/types/optional :: V -> V)<std/core/types/bool>, name : (std/core/types/optional :: V -> V)<std/core/types/string>, output : (std/core/types/optional :: V -> V)<std/core/types/string>, arguments : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>) -> myflags;
fun show-flag : forall<a> (flag : (flag :: V -> V)<a>) -> (std/core/list :: V -> V)<(std/core/types/string, std/core/types/string, std/core/types/string)>;
// monadic lift
fun .mlift5766-zipWith3Acc : forall<(e :: E),a,b,c,d> (acc : (std/core/list :: V -> V)<b>, f : (a, c, d) -> (e :: E) b, xx : (std/core/list :: V -> V)<a>, yy : (std/core/list :: V -> V)<c>, zz : (std/core/list :: V -> V)<d>, .y.5760 : b) -> (e :: E) (std/core/list :: V -> V)<b>;
fun zipWith3Acc : forall<a,b,c,d,(e :: E)> ((a, b, c) -> (e :: E) d, (std/core/list :: V -> V)<d>, (std/core/list :: V -> V)<a>, (std/core/list :: V -> V)<b>, (std/core/list :: V -> V)<c>) -> (e :: E) (std/core/list :: V -> V)<d>;
fun zipWith3 : forall<a,b,c,d,(e :: E)> (f : (a, b, c) -> (e :: E) d, xs : (std/core/list :: V -> V)<a>, ys : (std/core/list :: V -> V)<b>, zs : (std/core/list :: V -> V)<c>) -> (e :: E) (std/core/list :: V -> V)<d>;
// Return a nicely formatted string describing the usage of a command,
// consisting of a `header` followed by the descriptions of the `flags`.
// The default header is ``"usage:\n program [flags] arguments\n\nflags:"``.
pub fun usage : forall<a> (flags : (std/core/list :: V -> V)<(flag :: V -> V)<a>>, header : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
fun error-ambiguous : forall<a,b> (applicable : (std/core/list :: V -> V)<(flag :: V -> V)<a>>, opt : std/core/types/string) -> (flag-kind :: V -> V)<b>;
fun error-unknown : forall<a> (opt : std/core/types/string) -> (flag-kind :: V -> V)<a>;
fun parse-long : forall<a> (s : std/core/types/string, flags : (std/core/list :: V -> V)<(flag :: V -> V)<a>>) -> (std/core/total :: E) (flag-kind :: V -> V)<a>;
fun parse-shorts : forall<a> (s : std/core/types/string, flags : (std/core/list :: V -> V)<(flag :: V -> V)<a>>) -> (std/core/list :: V -> V)<(flag-kind :: V -> V)<a>>;
fun process-next : forall<a> (arg : std/core/types/string, flags : (std/core/list :: V -> V)<(flag :: V -> V)<a>>) -> (std/core/list :: V -> V)<(flag-kind :: V -> V)<a>>;
// Parse the command line arguments `args` (see `std/env/get-args`)
// according to the flag descriptions `flags`. Takes an flagal argument
// `ordering` (=`Permute`) that specifies how optare handled that follow non-flag arguments.
// Returns three lists: the list of parsed flags,
// a list of non-flag arguments, and a list of potential error messages.
pub fun parse : forall<a> (initial : a, flags : (std/core/list :: V -> V)<(flag :: V -> V)<a>>, args : (std/core/list :: V -> V)<std/core/types/string>, ordering : (std/core/types/optional :: V -> V)<(flag-order :: V -> V)<a>>) -> (std/core/total :: E) (a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>);
pub fun test : (cmdargs : (std/core/list :: V -> V)<std/core/types/string>) -> <(std/core/console :: X)> ();
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
specialize "_*_*" fun parse // inline size: 1
  = forall<a> fn<(std/core/total :: E)>(initial: a, flags: (std/core/list :: V -> V)<(flag :: V -> V)<a>>, args: (std/core/list :: V -> V)<std/core/types/string>, ordering: (std/core/types/optional :: V -> V)<(flag-order :: V -> V)<a>>){
    std/core/types/unsafe-no-local-cast<(a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>),(std/core/total :: E)>((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(){
      std/core/hnd/local-var<std/core/types/bool,(a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>),(std/core/total :: E),(h :: H)>(std/core/types/False, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(done: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/bool>){
          val opts0 : ((std/core/list :: V -> V)<(std/core/list :: V -> V)<(flag-kind :: V -> V)<a>>>)
                = (std/core/map.5<std/core/types/string,(std/core/list :: V -> V)<(flag-kind :: V -> V)<a>>,<(std/core/types/local :: H -> X)<(h :: H)>>>(args, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(arg: std/core/types/string){
                    val opts : ((std/core/list :: V -> V)<(flag-kind :: V -> V)<a>>)
                      = (match ((std/core/types/local-get<std/core/types/bool,(h :: H),(std/core/total :: E)>(done))) {
                        ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
                           -> std/core/Cons<(flag-kind :: V -> V)<a>>((std/os/flags/Arg<a>(arg)), (std/core/Nil<(flag-kind :: V -> V)<a>>));
                        ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
                           -> std/os/flags/process-next<a>(arg, flags);
                      });
                    val _ : ()
                      = (std/core/foreach<(flag-kind :: V -> V)<a>,<(std/core/types/local :: H -> X)<(h :: H)>>>(opts, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(opt: (flag-kind :: V -> V)<a>){
                          (match (opt) {
                            ((std/os/flags/End() : (flag-kind :: V -> V)<a> ) as .pat3: ((flag-kind :: V -> V)<a>))
                               -> std/core/types/local-set<std/core/types/bool,(std/core/total :: E),(h :: H)>(done, std/core/types/True);
                            ((std/os/flags/Arg((.pat5: std/core/types/string) : std/core/types/string) : (flag-kind :: V -> V)<a> ) as .pat4: ((flag-kind :: V -> V)<a>))
                               | (match ((match (ordering) {
                                ((std/core/types/Optional((.ordering.4986: (flag-order :: V -> V)<a>) : (flag-order :: V -> V)<a>) : (std/core/types/optional :: V -> V)<(flag-order :: V -> V)<a>> ) as .pat6: ((std/core/types/optional :: V -> V)<(flag-order :: V -> V)<a>>))
                                   -> .ordering.4986;
                                ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<(flag-order :: V -> V)<a>> ) as .pat00: ((std/core/types/optional :: V -> V)<(flag-order :: V -> V)<a>>))
                                   -> std/os/flags/Permute<a>;
                              })) {
                                ((std/os/flags/Preorder() : (flag-order :: V -> V)<a> ) as .pat: ((flag-order :: V -> V)<a>))
                                   -> std/core/types/True;
                                (.pat0: ((flag-order :: V -> V)<a>))
                                   -> std/core/types/False;
                              }) -> std/core/types/local-set<std/core/types/bool,(std/core/total :: E),(h :: H)>(done, std/core/types/True);
                            (.pat60: ((flag-kind :: V -> V)<a>))
                               -> std/core/types/();
                          });
                        })));
                    opts;
                  })));
          (std/core/foldl<(flag-kind :: V -> V)<a>,(a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>),<(std/core/types/local :: H -> X)<(h :: H)>>>((std/core/.lift17183-concat<(flag-kind :: V -> V)<a>>((std/core/Nil<(flag-kind :: V -> V)<a>>), opts0)), (std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>(initial, (std/core/Nil<std/core/types/string>), (std/core/Nil<std/core/types/string>))), (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(acc: (a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>), opt0: (flag-kind :: V -> V)<a>){
              (match (acc) {
                ((.skip std/core/types/(,,)((o: a) : a, (xs: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (errs: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>) ) as .pat7: (a, (std/core/list :: V -> V)<std/core/types/string>, (std/core/list :: V -> V)<std/core/types/string>))
                   -> (match (opt0) {
                    ((std/os/flags/Flg((set: (a) -> a) : (a) -> a) : (flag-kind :: V -> V)<a> ) as .pat8: ((flag-kind :: V -> V)<a>))
                       -> std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>((set(o)), xs, errs);
                    ((std/os/flags/Unknown((e: std/core/types/string) : std/core/types/string) : (flag-kind :: V -> V)<a> ) as .pat9: ((flag-kind :: V -> V)<a>))
                       -> std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>(o, xs, (std/core/Cons<std/core/types/string>((std/core/(++.1)("unrecognized flag \x22", (std/core/(++.1)(e, "\x22")))), errs)));
                    ((std/os/flags/Error((e0: std/core/types/string) : std/core/types/string) : (flag-kind :: V -> V)<a> ) as .pat10: ((flag-kind :: V -> V)<a>))
                       -> std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>(o, xs, (std/core/Cons<std/core/types/string>(e0, errs)));
                    ((std/os/flags/Arg((x: std/core/types/string) : std/core/types/string) : (flag-kind :: V -> V)<a> ) as .pat11: ((flag-kind :: V -> V)<a>))
                       -> std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>(o, (std/core/Cons<std/core/types/string>(x, xs)), errs);
                    ((.skip std/os/flags/End() : (flag-kind :: V -> V)<a> ) as .pat12: ((flag-kind :: V -> V)<a>))
                       -> std/core/types/(,,)<a,(std/core/list :: V -> V)<std/core/types/string>,(std/core/list :: V -> V)<std/core/types/string>>(o, xs, errs);
                  });
              });
            })));
        }));
    }))();
  };
specialize "**" fun parse-shorts // inline size: 1
  = forall<a> fn(s: std/core/types/string, flags: (std/core/list :: V -> V)<(flag :: V -> V)<a>>){
    std/core/types/unsafe-no-local-cast<(std/core/list :: V -> V)<(flag-kind :: V -> V)<a>>,(std/core/types/(<>) :: E)>((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(){
      std/core/hnd/local-var<std/core/types/bool,(std/core/list :: V -> V)<(flag-kind :: V -> V)<a>>,(std/core/types/(<>) :: E),(h :: H)>(std/core/types/False, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(done: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/bool>){
          val fs : ((std/core/list :: V -> V)<(std/core/types/maybe :: V -> V)<(flag-kind :: V -> V)<a>>>)
                = (std/core/map-indexed<std/core/types/char,(std/core/types/maybe :: V -> V)<(flag-kind :: V -> V)<a>>,<(std/core/types/local :: H -> X)<(h :: H)>>>((std/core/list.6(s)), (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(i: std/core/types/int, c: std/core/types/char){
                    (match ((std/core/types/local-get<std/core/types/bool,(h :: H),(std/core/types/(<>) :: E)>(done))) {
                      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
                         -> std/core/types/Nothing<(flag-kind :: V -> V)<a>>;
                      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
                         -> val optstr : std/core/types/string
                              = std/core/(++.1)("-", (std/core/string(c)));
                            val applicable : (std/core/list :: V -> V)<(flag :: V -> V)<a>>
                              = std/core/filter<(flag :: V -> V)<a>,<(std/core/types/local :: H -> X)<(h :: H)>>>(flags, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(opt: (flag :: V -> V)<a>){
                                  (std/core/contains((match (opt) {
                                      ((.skip std/os/flags/Flag((.x: std/core/types/string) : std/core/types/string, (.pat00: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat10: (flag-parser :: V -> V)<a>) : (flag-parser :: V -> V)<a>, (.pat2: std/core/types/string) : std/core/types/string) : (flag :: V -> V)<a> ) as .pat1: ((flag :: V -> V)<a>))
                                         -> .x;
                                    }), (std/core/string(c))));
                                }));
                        (match (applicable) {
                          ((std/core/Nil() : (std/core/list :: V -> V)<(flag :: V -> V)<a>> ) as .pat11: ((std/core/list :: V -> V)<(flag :: V -> V)<a>>))
                             -> std/core/types/Just<(flag-kind :: V -> V)<a>>((std/os/flags/Error<a>((std/core/(++.1)("unrecognized flag \x22", (std/core/(++.1)(optstr, "\x22")))))));
                          ((.skip std/core/Cons((.pat3: (flag :: V -> V)<a>) : (flag :: V -> V)<a>, ((std/core/Cons((.pat5: (flag :: V -> V)<a>) : (flag :: V -> V)<a>, (.pat6: (std/core/list :: V -> V)<(flag :: V -> V)<a>>) : (std/core/list :: V -> V)<(flag :: V -> V)<a>>) : (std/core/list :: V -> V)<(flag :: V -> V)<a>> ) as .pat4: (std/core/list :: V -> V)<(flag :: V -> V)<a>>) : (std/core/list :: V -> V)<(flag :: V -> V)<a>>) : (std/core/list :: V -> V)<(flag :: V -> V)<a>> ) as .pat20: ((std/core/list :: V -> V)<(flag :: V -> V)<a>>))
                             -> std/core/types/Just<(flag-kind :: V -> V)<a>>((std/os/flags/error-ambiguous<a,a>(applicable, optstr)));
                          ((.skip std/core/Cons((desc: (flag :: V -> V)<a>) : (flag :: V -> V)<a>, ((.skip std/core/Nil() : (std/core/list :: V -> V)<(flag :: V -> V)<a>> ) as .pat8: (std/core/list :: V -> V)<(flag :: V -> V)<a>>) : (std/core/list :: V -> V)<(flag :: V -> V)<a>>) : (std/core/list :: V -> V)<(flag :: V -> V)<a>> ) as .pat7: ((std/core/list :: V -> V)<(flag :: V -> V)<a>>))
                             -> (match (desc) {
                              ((.skip std/os/flags/Flag((.pat01: std/core/types/string) : std/core/types/string, (.pat12: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.x0: (flag-parser :: V -> V)<a>) : (flag-parser :: V -> V)<a>, (.pat21: std/core/types/string) : std/core/types/string) : (flag :: V -> V)<a> ) as .pat9: ((flag :: V -> V)<a>))
                                 -> (match (.x0) {
                                  ((std/os/flags/Bool((set: (a, std/core/types/bool) -> a) : (a, std/core/types/bool) -> a) : (flag-parser :: V -> V)<a> ) as .pat90: ((flag-parser :: V -> V)<a>))
                                     -> std/core/types/Just<(flag-kind :: V -> V)<a>>((std/os/flags/Flg<a>((fn(o: a){
                                      (set(o, std/core/types/True));
                                    }))));
                                  ((std/os/flags/Req((parse0: (a, std/core/types/string) -> a) : (a, std/core/types/string) -> a, (help0: std/core/types/string) : std/core/types/string) : (flag-parser :: V -> V)<a> ) as .pat100: ((flag-parser :: V -> V)<a>))
                                     -> val arg : std/core/types/string
                                              = std/core/string.3((std/core/after((std/core/advance((std/core/first(s, (std/core/types/None<std/core/types/int>))), i)))));
                                    (match ((std/core/(!=.3)(arg, ""))) {
                                      ((std/core/types/True() : std/core/types/bool ) as .pat110: std/core/types/bool)
                                         -> val _0 : ()
                                                  = std/core/types/local-set<std/core/types/bool,(std/core/types/(<>) :: E),(h :: H)>(done, std/core/types/True);
                                        std/core/types/Just<(flag-kind :: V -> V)<a>>((std/os/flags/Flg<a>((fn(o0: a){
                                          (parse0(o0, arg));
                                        }))));
                                      ((.skip std/core/types/False() : std/core/types/bool ) as .pat120: std/core/types/bool)
                                         -> std/core/types/Just<(flag-kind :: V -> V)<a>>((std/os/flags/Error<a>((std/core/(++.1)("flag \x22", (std/core/(++.1)(optstr, (std/core/(++.1)("\x22 requires an argument ", help0)))))))));
                                    });
                                  ((.skip std/os/flags/Opt((parse00: (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a) : (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, (.pat14: std/core/types/string) : std/core/types/string) : (flag-parser :: V -> V)<a> ) as .pat13: ((flag-parser :: V -> V)<a>))
                                     -> val arg0 : std/core/types/string
                                              = std/core/string.3((std/core/after((std/core/advance((std/core/first(s, (std/core/types/None<std/core/types/int>))), i)))));
                                    (match ((std/core/(!=.3)(arg0, ""))) {
                                      ((std/core/types/True() : std/core/types/bool ) as .pat15: std/core/types/bool)
                                         -> val _1 : ()
                                                  = std/core/types/local-set<std/core/types/bool,(std/core/types/(<>) :: E),(h :: H)>(done, std/core/types/True);
                                        std/core/types/Just<(flag-kind :: V -> V)<a>>((std/os/flags/Flg<a>((fn(o1: a){
                                          (parse00(o1, (std/core/types/Just<std/core/types/string>(arg0))));
                                        }))));
                                      ((.skip std/core/types/False() : std/core/types/bool ) as .pat16: std/core/types/bool)
                                         -> std/core/types/Just<(flag-kind :: V -> V)<a>>((std/os/flags/Flg<a>((fn(o2: a){
                                          (parse00(o2, (std/core/types/Nothing<std/core/types/string>)));
                                        }))));
                                    });
                                });
                            });
                        });
                    });
                  })));
          (std/core/flatmap<(std/core/types/maybe :: V -> V)<(flag-kind :: V -> V)<a>>,(flag-kind :: V -> V)<a>,<(std/core/types/local :: H -> X)<(h :: H)>>>(fs, (std/core/list.5<(flag-kind :: V -> V)<a>>)));
        }));
    }))();
  };
specialize "_*" fun process-next // inline size: 1
  = forall<a> fn(arg: std/core/types/string, flags: (std/core/list :: V -> V)<(flag :: V -> V)<a>>){
    (match ((std/core/starts-with(arg, "--"))) {
      ((std/core/types/Just(((.skip std/core/Sslice((.pat0: std/core/types/string) : std/core/types/string, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat2: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as slice: std/core/sslice) : std/core/sslice) : (std/core/types/maybe :: V -> V)<std/core/sslice> ) as .pat: ((std/core/types/maybe :: V -> V)<std/core/sslice>))
         -> val b.17019 : std/core/types/bool
                  = std/core/is-pos.1((match (slice) {
                    ((.skip std/core/Sslice((.pat00: std/core/types/string) : std/core/types/string, (.pat100: std/core/types/ssize_t) : std/core/types/ssize_t, (.x: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as .pat10: std/core/sslice)
                       -> .x;
                  }));
        (match (b.17019) {
          ((std/core/types/True() : std/core/types/bool ) as .pat3: std/core/types/bool)
             -> std/core/Cons<(flag-kind :: V -> V)<a>>((std/os/flags/parse-long<a>((std/core/string.3(slice)), flags)), (std/core/Nil<(flag-kind :: V -> V)<a>>));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat01: std/core/types/bool)
             -> std/core/Cons<(flag-kind :: V -> V)<a>>((std/os/flags/End<a>), (std/core/Nil<(flag-kind :: V -> V)<a>>));
        });
      ((.skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<std/core/sslice> ) as .pat5: ((std/core/types/maybe :: V -> V)<std/core/sslice>))
         -> (match ((std/core/starts-with(arg, "-"))) {
          ((std/core/types/Just((slice00: std/core/sslice) : std/core/sslice) : (std/core/types/maybe :: V -> V)<std/core/sslice> ) as .pat6: ((std/core/types/maybe :: V -> V)<std/core/sslice>))
             | val b.170190 : std/core/types/bool
                     = std/core/is-pos.1((match (slice00) {
                       ((.skip std/core/Sslice((.pat000: std/core/types/string) : std/core/types/string, (.pat101: std/core/types/ssize_t) : std/core/types/ssize_t, (.x0: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as .pat11: std/core/sslice)
                          -> .x0;
                     }));
            (match (b.170190) {
              ((std/core/types/True() : std/core/types/bool ) as .pat8: std/core/types/bool)
                 -> std/core/types/True;
              ((.skip std/core/types/False() : std/core/types/bool ) as .pat03: std/core/types/bool)
                 -> std/core/types/False;
            }) -> std/os/flags/parse-shorts<a>((std/core/string.3(slice00)), flags);
          (.pat70: ((std/core/types/maybe :: V -> V)<std/core/sslice>))
             -> std/core/Cons<(flag-kind :: V -> V)<a>>((std/os/flags/Arg<a>(arg)), (std/core/Nil<(flag-kind :: V -> V)<a>>));
        });
    });
  };
specialize "*" fun show-flag // inline size: 1
  = forall<a> fn(flag: (flag :: V -> V)<a>){
    val xs.5631 : (std/core/list :: V -> V)<std/core/types/string>
      = std/core/map.5<std/core/types/char,std/core/types/string,(std/core/types/(<>) :: E)>((std/core/list.6((match (flag) {
          ((.skip std/os/flags/Flag((.x: std/core/types/string) : std/core/types/string, (.pat0: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat1: (flag-parser :: V -> V)<a>) : (flag-parser :: V -> V)<a>, (.pat2: std/core/types/string) : std/core/types/string) : (flag :: V -> V)<a> ) as .pat: ((flag :: V -> V)<a>))
             -> .x;
        }))), (fn(c: std/core/types/char){
          (std/core/(++.1)("-", (std/core/(++.1)((std/core/string(c)), (match (flag) {
                ((.skip std/os/flags/Flag((.pat01: std/core/types/string) : std/core/types/string, (.pat11: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.x0: (flag-parser :: V -> V)<a>) : (flag-parser :: V -> V)<a>, (.pat21: std/core/types/string) : std/core/types/string) : (flag :: V -> V)<a> ) as .pat5: ((flag :: V -> V)<a>))
                   -> (match (.x0) {
                    ((std/os/flags/Bool((.pat00: (a, std/core/types/bool) -> a) : (a, std/core/types/bool) -> a) : (flag-parser :: V -> V)<a> ) as .pat3: ((flag-parser :: V -> V)<a>))
                       -> "";
                    ((std/os/flags/Req((.pat20: (a, std/core/types/string) -> a) : (a, std/core/types/string) -> a, (h: std/core/types/string) : std/core/types/string) : (flag-parser :: V -> V)<a> ) as .pat10: ((flag-parser :: V -> V)<a>))
                       -> std/core/(++.1)("<", (std/core/(++.1)(h, ">")));
                    ((.skip std/os/flags/Opt((.pat4: (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a) : (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, (h0: std/core/types/string) : std/core/types/string) : (flag-parser :: V -> V)<a> ) as .pat30: ((flag-parser :: V -> V)<a>))
                       -> std/core/(++.1)("[", (std/core/(++.1)(h0, "]")));
                  });
              })))));
        }));
    val short : std/core/types/string
      = (match (xs.5631) {
        ((std/core/Nil() : (std/core/list :: V -> V)<std/core/types/string> ) as .pat12: ((std/core/list :: V -> V)<std/core/types/string>))
           -> "";
        ((.skip std/core/Cons((x: std/core/types/string) : std/core/types/string, (xx: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string> ) as .pat22: ((std/core/list :: V -> V)<std/core/types/string>))
           -> std/core/.lift17188-joinsep(" ", xx, x);
      });
    val xs0.5636 : (std/core/list :: V -> V)<std/core/types/string>
      = std/core/map.5<std/core/types/string,std/core/types/string,(std/core/types/(<>) :: E)>((match (flag) {
          ((.skip std/os/flags/Flag((.pat02: std/core/types/string) : std/core/types/string, (.x1: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat120: (flag-parser :: V -> V)<a>) : (flag-parser :: V -> V)<a>, (.pat220: std/core/types/string) : std/core/types/string) : (flag :: V -> V)<a> ) as .pat6: ((flag :: V -> V)<a>))
             -> .x1;
        }), (fn(name0: std/core/types/string){
          (std/core/(++.1)("--", (std/core/(++.1)(name0, (match (flag) {
                ((.skip std/os/flags/Flag((.pat04: std/core/types/string) : std/core/types/string, (.pat14: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.x2: (flag-parser :: V -> V)<a>) : (flag-parser :: V -> V)<a>, (.pat24: std/core/types/string) : std/core/types/string) : (flag :: V -> V)<a> ) as .pat8: ((flag :: V -> V)<a>))
                   -> (match (.x2) {
                    ((std/os/flags/Bool((.pat03: (a, std/core/types/bool) -> a) : (a, std/core/types/bool) -> a) : (flag-parser :: V -> V)<a> ) as .pat7: ((flag-parser :: V -> V)<a>))
                       -> "";
                    ((std/os/flags/Req((.pat23: (a, std/core/types/string) -> a) : (a, std/core/types/string) -> a, (h1: std/core/types/string) : std/core/types/string) : (flag-parser :: V -> V)<a> ) as .pat13: ((flag-parser :: V -> V)<a>))
                       -> std/core/(++.1)("=", h1);
                    ((.skip std/os/flags/Opt((.pat40: (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a) : (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, (h00: std/core/types/string) : std/core/types/string) : (flag-parser :: V -> V)<a> ) as .pat31: ((flag-parser :: V -> V)<a>))
                       -> std/core/(++.1)("[=", (std/core/(++.1)(h00, "]")));
                  });
              })))));
        }));
    val long : std/core/types/string
      = (match (xs0.5636) {
        ((std/core/Nil() : (std/core/list :: V -> V)<std/core/types/string> ) as .pat15: ((std/core/list :: V -> V)<std/core/types/string>))
           -> "";
        ((.skip std/core/Cons((x0: std/core/types/string) : std/core/types/string, (xx0: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string> ) as .pat25: ((std/core/list :: V -> V)<std/core/types/string>))
           -> std/core/.lift17188-joinsep(" ", xx0, x0);
      });
    val v.17126 : (std/core/types/vector :: V -> V)<std/core/types/string>
      = std/core/splitv((match (flag) {
          ((.skip std/os/flags/Flag((.pat05: std/core/types/string) : std/core/types/string, (.pat150: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat250: (flag-parser :: V -> V)<a>) : (flag-parser :: V -> V)<a>, (.x3: std/core/types/string) : std/core/types/string) : (flag :: V -> V)<a> ) as .pat9: ((flag :: V -> V)<a>))
             -> .x3;
        }), "\x0A");
    (match ((std/core/vlist<std/core/types/string>(v.17126, (std/core/types/None<(std/core/list :: V -> V)<std/core/types/string>>)))) {
      ((std/core/Cons((hd: std/core/types/string) : std/core/types/string, (tl: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string> ) as .pat16: ((std/core/list :: V -> V)<std/core/types/string>))
         -> val ys.5644 : (std/core/list :: V -> V)<(std/core/types/string, std/core/types/string, std/core/types/string)>
                  = std/core/map.5<std/core/types/string,(std/core/types/string, std/core/types/string, std/core/types/string),(std/core/types/(<>) :: E)>(tl, (fn(s0: std/core/types/string){
                      (std/core/types/(,,)<std/core/types/string,std/core/types/string,std/core/types/string>("", "", s0));
                    }));
        std/core/append<(std/core/types/string, std/core/types/string, std/core/types/string)>((std/core/Cons<(std/core/types/string, std/core/types/string, std/core/types/string)>((std/core/types/(,,)<std/core/types/string,std/core/types/string,std/core/types/string>(short, long, hd)), (std/core/Nil<(std/core/types/string, std/core/types/string, std/core/types/string)>))), ys.5644);
      ((.skip std/core/Nil() : (std/core/list :: V -> V)<std/core/types/string> ) as .pat06: ((std/core/list :: V -> V)<std/core/types/string>))
         -> std/core/Cons<(std/core/types/string, std/core/types/string, std/core/types/string)>((std/core/types/(,,)<std/core/types/string,std/core/types/string,std/core/types/string>(short, long, "")), (std/core/Nil<(std/core/types/string, std/core/types/string, std/core/types/string)>));
    });
  };
specialize "*___" fun zipWith3 // inline size: 1
  = forall<a,b,c,d,(e :: E)> fn<(e :: E)>(f: (a, b, c) -> (e :: E) d, xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>, zs: (std/core/list :: V -> V)<c>){
    std/os/flags/zipWith3Acc<a,b,c,d,(e :: E)>(f, (std/core/Nil<d>), xs, ys, zs);
  };
recursive specialize "*____" fun zipWith3Acc // inline size: 12
  = forall<a,b,c,d,(e :: E)> fn<(e :: E)>(f: (a, b, c) -> (e :: E) d, acc: (std/core/list :: V -> V)<d>, xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>, zs: (std/core/list :: V -> V)<c>){
    (match (xs) {
      ((std/core/Nil() : (std/core/list :: V -> V)<a> ) as .pat: ((std/core/list :: V -> V)<a>))
         -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<d>) -> (std/core/list :: V -> V)<d>,(xs : (std/core/list :: V -> V)<d>) -> (e :: E) (std/core/list :: V -> V)<d>>((std/core/reverse<d>))(acc);
      ((.skip std/core/Cons((x: a) : a, (xx: (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a>) : (std/core/list :: V -> V)<a> ) as .pat0: ((std/core/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/Nil() : (std/core/list :: V -> V)<b> ) as .pat1: ((std/core/list :: V -> V)<b>))
             -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<d>) -> (std/core/list :: V -> V)<d>,(xs : (std/core/list :: V -> V)<d>) -> (e :: E) (std/core/list :: V -> V)<d>>((std/core/reverse<d>))(acc);
          ((.skip std/core/Cons((y: b) : b, (yy: (std/core/list :: V -> V)<b>) : (std/core/list :: V -> V)<b>) : (std/core/list :: V -> V)<b> ) as .pat2: ((std/core/list :: V -> V)<b>))
             -> (match (zs) {
              ((std/core/Cons((z: c) : c, (zz: (std/core/list :: V -> V)<c>) : (std/core/list :: V -> V)<c>) : (std/core/list :: V -> V)<c> ) as .pat3: ((std/core/list :: V -> V)<c>))
                 -> std/os/flags/zipWith3Acc<a,b,c,d,(e :: E)>(f, (std/core/Cons<d>((f(x, y, z)), acc)), xx, yy, zz);
              ((.skip std/core/Nil() : (std/core/list :: V -> V)<c> ) as .pat4: ((std/core/list :: V -> V)<c>))
                 -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<d>) -> (std/core/list :: V -> V)<d>,(xs : (std/core/list :: V -> V)<d>) -> (e :: E) (std/core/list :: V -> V)<d>>((std/core/reverse<d>))(acc);
            });
        });
    });
  };
inline borrow "^" fun is-bool // inline size: 1
  = forall<a> fn(flag-parser: (flag-parser :: V -> V)<a>){
    (match (flag-parser) {
      ((std/os/flags/Bool((.pat0: (a, std/core/types/bool) -> a) : (a, std/core/types/bool) -> a) : (flag-parser :: V -> V)<a> ) as .pat: ((flag-parser :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((flag-parser :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-req // inline size: 1
  = forall<a> fn(flag-parser: (flag-parser :: V -> V)<a>){
    (match (flag-parser) {
      ((std/os/flags/Req((.pat0: (a, std/core/types/string) -> a) : (a, std/core/types/string) -> a, (.pat1: std/core/types/string) : std/core/types/string) : (flag-parser :: V -> V)<a> ) as .pat: ((flag-parser :: V -> V)<a>))
         -> std/core/types/True;
      (.pat2: ((flag-parser :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-opt // inline size: 1
  = forall<a> fn(flag-parser: (flag-parser :: V -> V)<a>){
    (match (flag-parser) {
      ((std/os/flags/Opt((.pat0: (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a) : (a, (std/core/types/maybe :: V -> V)<std/core/types/string>) -> a, (.pat1: std/core/types/string) : std/core/types/string) : (flag-parser :: V -> V)<a> ) as .pat: ((flag-parser :: V -> V)<a>))
         -> std/core/types/True;
      (.pat2: ((flag-parser :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun short-names // inline size: 0
  = forall<a> fn(flag: (flag :: V -> V)<a>){
    (match (flag) {
      ((.skip std/os/flags/Flag((.x: std/core/types/string) : std/core/types/string, (.pat0: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat1: (flag-parser :: V -> V)<a>) : (flag-parser :: V -> V)<a>, (.pat2: std/core/types/string) : std/core/types/string) : (flag :: V -> V)<a> ) as .pat: ((flag :: V -> V)<a>))
         -> .x;
    });
  };
inline borrow "^" fun long-names // inline size: 0
  = forall<a> fn(flag: (flag :: V -> V)<a>){
    (match (flag) {
      ((.skip std/os/flags/Flag((.pat0: std/core/types/string) : std/core/types/string, (.x: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat1: (flag-parser :: V -> V)<a>) : (flag-parser :: V -> V)<a>, (.pat2: std/core/types/string) : std/core/types/string) : (flag :: V -> V)<a> ) as .pat: ((flag :: V -> V)<a>))
         -> .x;
    });
  };
inline borrow "^" fun parser // inline size: 0
  = forall<a> fn(flag: (flag :: V -> V)<a>){
    (match (flag) {
      ((.skip std/os/flags/Flag((.pat0: std/core/types/string) : std/core/types/string, (.pat1: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.x: (flag-parser :: V -> V)<a>) : (flag-parser :: V -> V)<a>, (.pat2: std/core/types/string) : std/core/types/string) : (flag :: V -> V)<a> ) as .pat: ((flag :: V -> V)<a>))
         -> .x;
    });
  };
inline borrow "^" fun help // inline size: 0
  = forall<a> fn(flag: (flag :: V -> V)<a>){
    (match (flag) {
      ((.skip std/os/flags/Flag((.pat0: std/core/types/string) : std/core/types/string, (.pat1: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>, (.pat2: (flag-parser :: V -> V)<a>) : (flag-parser :: V -> V)<a>, (.x: std/core/types/string) : std/core/types/string) : (flag :: V -> V)<a> ) as .pat: ((flag :: V -> V)<a>))
         -> .x;
    });
  };
inline borrow "^" fun is-flg // inline size: 1
  = forall<a> fn(flag-kind: (flag-kind :: V -> V)<a>){
    (match (flag-kind) {
      ((std/os/flags/Flg((.pat0: (a) -> a) : (a) -> a) : (flag-kind :: V -> V)<a> ) as .pat: ((flag-kind :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((flag-kind :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-arg // inline size: 1
  = forall<a> fn(flag-kind: (flag-kind :: V -> V)<a>){
    (match (flag-kind) {
      ((std/os/flags/Arg((.pat0: std/core/types/string) : std/core/types/string) : (flag-kind :: V -> V)<a> ) as .pat: ((flag-kind :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((flag-kind :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-end // inline size: 1
  = forall<a> fn(flag-kind: (flag-kind :: V -> V)<a>){
    (match (flag-kind) {
      ((std/os/flags/End() : (flag-kind :: V -> V)<a> ) as .pat: ((flag-kind :: V -> V)<a>))
         -> std/core/types/True;
      (.pat0: ((flag-kind :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-unknown // inline size: 1
  = forall<a> fn(flag-kind: (flag-kind :: V -> V)<a>){
    (match (flag-kind) {
      ((std/os/flags/Unknown((.pat0: std/core/types/string) : std/core/types/string) : (flag-kind :: V -> V)<a> ) as .pat: ((flag-kind :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((flag-kind :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-error // inline size: 1
  = forall<a> fn(flag-kind: (flag-kind :: V -> V)<a>){
    (match (flag-kind) {
      ((std/os/flags/Error((.pat0: std/core/types/string) : std/core/types/string) : (flag-kind :: V -> V)<a> ) as .pat: ((flag-kind :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((flag-kind :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-permute // inline size: 1
  = forall<a> fn(flag-order: (flag-order :: V -> V)<a>){
    (match (flag-order) {
      ((std/os/flags/Permute() : (flag-order :: V -> V)<a> ) as .pat: ((flag-order :: V -> V)<a>))
         -> std/core/types/True;
      (.pat0: ((flag-order :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-preorder // inline size: 1
  = forall<a> fn(flag-order: (flag-order :: V -> V)<a>){
    (match (flag-order) {
      ((std/os/flags/Preorder() : (flag-order :: V -> V)<a> ) as .pat: ((flag-order :: V -> V)<a>))
         -> std/core/types/True;
      (.pat0: ((flag-order :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-wrap // inline size: 1
  = forall<a> fn(flag-order: (flag-order :: V -> V)<a>){
    (match (flag-order) {
      ((std/os/flags/Wrap((.pat0: (std/core/types/string) -> a) : (std/core/types/string) -> a) : (flag-order :: V -> V)<a> ) as .pat: ((flag-order :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((flag-order :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun verbose // inline size: 0
  = fn(myflags0: myflags){
    match (myflags0) {
      ((.skip std/os/flags/Myflags((.x: std/core/types/bool) : std/core/types/bool, (.pat0: std/core/types/bool) : std/core/types/bool, (.pat1: std/core/types/string) : std/core/types/string, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : myflags ) as .pat: myflags)
         -> .x;
    };
  };
inline borrow "^" fun version // inline size: 0
  = fn(myflags0: myflags){
    match (myflags0) {
      ((.skip std/os/flags/Myflags((.pat0: std/core/types/bool) : std/core/types/bool, (.x: std/core/types/bool) : std/core/types/bool, (.pat1: std/core/types/string) : std/core/types/string, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : myflags ) as .pat: myflags)
         -> .x;
    };
  };
inline borrow "^" fun name // inline size: 0
  = fn(myflags0: myflags){
    match (myflags0) {
      ((.skip std/os/flags/Myflags((.pat0: std/core/types/bool) : std/core/types/bool, (.pat1: std/core/types/bool) : std/core/types/bool, (.x: std/core/types/string) : std/core/types/string, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : myflags ) as .pat: myflags)
         -> .x;
    };
  };
inline borrow "^" fun output // inline size: 0
  = fn(myflags0: myflags){
    match (myflags0) {
      ((.skip std/os/flags/Myflags((.pat0: std/core/types/bool) : std/core/types/bool, (.pat1: std/core/types/bool) : std/core/types/bool, (.pat2: std/core/types/string) : std/core/types/string, (.x: std/core/types/string) : std/core/types/string, (.pat3: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : myflags ) as .pat: myflags)
         -> .x;
    };
  };
inline borrow "^" fun arguments // inline size: 0
  = fn(myflags0: myflags){
    match (myflags0) {
      ((.skip std/os/flags/Myflags((.pat0: std/core/types/bool) : std/core/types/bool, (.pat1: std/core/types/bool) : std/core/types/bool, (.pat2: std/core/types/string) : std/core/types/string, (.pat3: std/core/types/string) : std/core/types/string, (.x: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : myflags ) as .pat: myflags)
         -> .x;
    };
  };
fun unzip3 // inline size: 1
  = forall<a,b,c> fn(xs: (std/core/list :: V -> V)<(a, b, c)>){
    std/os/flags/.lift5759-unzip3<a,b,c>(xs, (std/core/Nil<a>), (std/core/Nil<b>), (std/core/Nil<c>));
  };
fun error-negate // inline size: 3
  = forall<a> fn(flagname: std/core/types/string){
    std/os/flags/Error<a>((std/core/(++.1)("flag \x22--", (std/core/(++.1)(flagname, "\x22 cannot be negated")))));
  };
fun error-noarg // inline size: 3
  = forall<a> fn(opt: std/core/types/string){
    std/os/flags/Error<a>((std/core/(++.1)("flag \x22", (std/core/(++.1)(opt, "\x22 does not take an argument")))));
  };
fun error-required // inline size: 4
  = forall<a> fn(help0: std/core/types/string, opt: std/core/types/string){
    std/os/flags/Error<a>((std/core/(++.1)("flag \x22", (std/core/(++.1)(opt, (std/core/(++.1)("\x22 requires an argument ", help0)))))));
  };
fun error-unknown-message // inline size: 2
  = fn(opt: std/core/types/string){
    std/core/(++.1)("unrecognized flag \x22", (std/core/(++.1)(opt, "\x22")));
  };
inline fun .create-Myflags // inline size: 6
  = fn(verbose0: (std/core/types/optional :: V -> V)<std/core/types/bool>, version0: (std/core/types/optional :: V -> V)<std/core/types/bool>, name0: (std/core/types/optional :: V -> V)<std/core/types/string>, output0: (std/core/types/optional :: V -> V)<std/core/types/string>, arguments0: (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>){
    std/os/flags/Myflags((match (verbose0) {
        ((std/core/types/Optional((.verbose.2073: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> .verbose.2073;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> std/core/types/False;
      }), (match (version0) {
        ((std/core/types/Optional((.version.2077: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat1: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> .version.2077;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> std/core/types/False;
      }), (match (name0) {
        ((std/core/types/Optional((.name.2081: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat3: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> .name.2081;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat4: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> "";
      }), (match (output0) {
        ((std/core/types/Optional((.output.2085: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat5: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> .output.2085;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat6: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> "";
      }), (match (arguments0) {
        ((std/core/types/Optional((.arguments.2090: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>> ) as .pat7: ((std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>))
           -> .arguments.2090;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>> ) as .pat8: ((std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>))
           -> std/core/Nil<std/core/types/string>;
      }));
  };
fun zipWith3 // inline size: 1
  = forall<a,b,c,d,(e :: E)> fn<(e :: E)>(f: (a, b, c) -> (e :: E) d, xs: (std/core/list :: V -> V)<a>, ys: (std/core/list :: V -> V)<b>, zs: (std/core/list :: V -> V)<c>){
    std/os/flags/zipWith3Acc<a,b,c,d,(e :: E)>(f, (std/core/Nil<d>), xs, ys, zs);
  };
fun error-unknown // inline size: 3
  = forall<a> fn(opt: std/core/types/string){
    std/os/flags/Error<a>((std/core/(++.1)("unrecognized flag \x22", (std/core/(++.1)(opt, "\x22")))));
  };