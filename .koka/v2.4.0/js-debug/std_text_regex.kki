/* Regular expressions.

   The regular expressions conform to the regular expressions of JavaScript
   as described at <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions>
*/
module interface std/text/regex
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core/hnd = std/core/hnd = "";
import std/core = std/core = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 
// Abstract type of a regular expression object
pub value{0,2} type regex {
  // Abstract type of a regular expression object
  con Regex(obj: std/core/types/any, src: std/core/types/string) : (obj : std/core/types/any, src : std/core/types/string) -> regex;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `obj` constructor field of the `:regex` type.
fun obj : (^ regex : regex) -> std/core/types/any;
// Automatically generated. Retrieves the `src` constructor field of the `:regex` type.
fun src : (^ regex : regex) -> std/core/types/string;
pub fun .copy : (.this : regex, obj : (std/core/types/optional :: V -> V)<std/core/types/any>, src : (std/core/types/optional :: V -> V)<std/core/types/string>) -> regex;
// Return the full matched string of a capture group
pub fun captured : (matched : (std/core/list :: V -> V)<std/core/sslice>) -> std/core/types/string;
fun regex-exec : (regex : std/core/types/any, str : std/core/types/string, start : std/core/types/ssize_t) -> (std/core/list :: V -> V)<std/core/sslice>;
fun regex-exec-all : (regex : std/core/types/any, str : std/core/types/string, start : std/core/types/ssize_t, atmost : std/core/types/ssize_t) -> (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>;
fun regex-create : (source : std/core/types/string, ignore-case : std/core/types/bool, multi-line : std/core/types/bool) -> std/core/types/any;
// Return the pattern as a string
pub fun source : (r : regex) -> std/core/types/string;
// Check if a capture group was matched.
pub fun matched : (s : std/core/sslice) -> std/core/types/bool;
// Return the full matched string part for a list of matched capture groups.
pub fun captures : (xs : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>) -> (std/core/list :: V -> V)<std/core/types/string>;
// monadic lift
fun .mlift1030-concat-replace : forall<(e :: E)> (acc : (std/core/list :: V -> V)<std/core/types/string>, mm : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>, pre : (std/core/list :: V -> V)<std/core/sslice>, repl : ((std/core/list :: V -> V)<std/core/sslice>) -> (e :: E) std/core/types/string, .y.1018 : std/core/types/string) -> (e :: E) std/core/types/string;
fun concat-replace : forall<(e :: E)> (matches : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>, repl : ((std/core/list :: V -> V)<std/core/sslice>) -> (e :: E) std/core/types/string, acc : (std/core/list :: V -> V)<std/core/types/string>) -> (e :: E) std/core/types/string;
// Find a match for a regular expression.
// See also `find` and `contains`
pub fun exec : (regex : regex, s : std/core/types/string) -> (std/core/list :: V -> V)<std/core/sslice>;
// Does a regular expression pattern occur in a string `s`?
// (note: called `test` in javascript)
pub fun contains : (s : std/core/types/string, r : regex) -> std/core/types/bool;
// Match a regular expression `regex` over a string `s`. 
// Matches at most `atmost` times (and matches all by default).
// Returns always an odd number of elements where every even
// element is a match and the odd ones the string parts between the 
// matches. 
// See also `find-all` and `strings`.
pub fun exec-all : (regex : regex, s : std/core/types/string, atmost : (std/core/types/optional :: V -> V)<std/core/types/int>) -> (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>;
// Filter only for the matched parts.
fun .ctail-filter-matches : (xs : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>, .acc : (std/core/types/ctail :: V -> V)<(std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>>) -> (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>;
// Filter only for the matched parts.
fun filter-matches : (xs : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>) -> (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>;
// Filter only for the non-matched parts.
fun .ctail-filter-non-matches : (xs : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>, .acc : (std/core/types/ctail :: V -> V)<(std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>>) -> (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>;
// Filter only for the non-matched parts.
fun filter-non-matches : (xs : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>) -> (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>;
// Find a match for a regular expression.
// See also `exec`
pub fun find : (s : std/core/types/string, r : regex) -> (std/core/types/maybe :: V -> V)<std/core/types/string>;
// Find all matches for a regular expression in a string.
pub fun find-all : (s : std/core/types/string, r : regex, atmost : (std/core/types/optional :: V -> V)<std/core/types/int>) -> (std/core/list :: V -> V)<std/core/types/string>;
// Create a new regular expression. Takes two optional parameters. Set `ignoreCase` to `True`
// to ignore uppercase/lowercase distinction. If  `multiline` is set to `True`, then `^` and `$`
// match also the beginning and end of every line (instead of the entire input).
pub fun regex : (regex : std/core/types/string, ignorecase : (std/core/types/optional :: V -> V)<std/core/types/bool>, multiline : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> regex;
// Replace the all occurrences of `regex` by the result of the replacement fun `repl` in a string `s`.
pub fun replace-all : forall<(e :: E)> (s : std/core/types/string, r : regex, repl : ((std/core/list :: V -> V)<std/core/sslice>) -> (e :: E) std/core/types/string, atmost : (std/core/types/optional :: V -> V)<std/core/types/int>) -> (e :: E) std/core/types/string;
// Replace using a replacement string that can contain `$$` for a `$` sign, `$n` for a capture group,
// `$&` for the entire match `==$0`.
fun replace-captures : (caps : (std/core/list :: V -> V)<std/core/sslice>, repl : std/core/types/string) -> std/core/types/string;
// Replace all occurrences of `regex` with the replacement string `repl` in a string `s`.
// The replacement string can contain `$$` for a `$` sign, `$n` for a capture group,
// `$&` for the entire match `==$0`.
pub fun replace-all.1 : (s : std/core/types/string, regex : regex, repl : std/core/types/string, atmost : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
val rx-nongroup : regex;
// How many groups are captured by this regex?
pub fun groups-count : (r : regex) -> std/core/types/int;
// Replace the first occurrence of `regex` by the result of the replacement fun `repl` in a string `s`.
pub fun replace : forall<(e :: E)> (s : std/core/types/string, r : regex, repl : ((std/core/list :: V -> V)<std/core/sslice>) -> (e :: E) std/core/types/string) -> (e :: E) std/core/types/string;
// Replace the first occurrence of `regex` with a replacement string `repl` in a string `s`.
// The replacement string can contain `$$` for a `$` sign, `$n` for a capture group,
// `$&` for the entire match `==$0`.
pub fun replace.1 : (s : std/core/types/string, regex : regex, repl : std/core/types/string) -> std/core/types/string;
// Split a string `s` in at most `atmost` parts using a regular expression `r` as separator.
pub fun split : (s : std/core/types/string, r : regex, atmost : (std/core/types/optional :: V -> V)<std/core/types/int>) -> (std/core/list :: V -> V)<std/core/types/string>;
pub fun testabc : (s : std/core/types/string) -> std/core/types/bool;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
recursive specialize "_*_" fun concat-replace // inline size: 25
  = forall<(e :: E)> fn<(e :: E)>(matches: (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>, repl: ((std/core/list :: V -> V)<std/core/sslice>) -> (e :: E) std/core/types/string, acc: (std/core/list :: V -> V)<std/core/types/string>){
    (match (matches) {
      ((std/core/Cons((pre: (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice>, ((std/core/Cons((m: (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice>, (mm: (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>) : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>) : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>> ) as .pat0: (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>) : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>) : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>> ) as .pat: ((std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>))
         -> std/text/regex/concat-replace<(e :: E)>(mm, repl, (std/core/Cons<std/core/types/string>((repl(m)), (std/core/Cons<std/core/types/string>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(matched : (std/core/list :: V -> V)<std/core/sslice>) -> std/core/types/string,(matched : (std/core/list :: V -> V)<std/core/sslice>) -> (e :: E) std/core/types/string>((fn(matched0: (std/core/list :: V -> V)<std/core/sslice>){
                (match (matched0) {
                  ((std/core/Cons(((.skip std/core/Sslice((.pat00: std/core/types/string) : std/core/types/string, (.pat10: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat2: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as s: std/core/sslice) : std/core/sslice, (.pat3: (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice> ) as .pat1: ((std/core/list :: V -> V)<std/core/sslice>))
                     -> std/core/string.3(s);
                  ((.skip std/core/Nil() : (std/core/list :: V -> V)<std/core/sslice> ) as .pat4: ((std/core/list :: V -> V)<std/core/sslice>))
                     -> "";
                });
              }))(pre)), acc)))));
      ((std/core/Cons((post: (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice>, ((.skip std/core/Nil() : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>> ) as .pat20: (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>) : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>) : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>> ) as .pat11: ((std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>))
         -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<std/core/types/string>) -> std/core/types/string,(xs : (std/core/list :: V -> V)<std/core/types/string>) -> (e :: E) std/core/types/string>((fn(xs: (std/core/list :: V -> V)<std/core/types/string>){
          val xs0.17151 : ((std/core/list :: V -> V)<std/core/types/string>)
                = (std/core/.lift17200-reverse-join<std/core/types/string>((std/core/Nil<std/core/types/string>), xs));
          (match (xs0.17151) {
            ((std/core/Nil() : (std/core/list :: V -> V)<std/core/types/string> ) as .pat100: ((std/core/list :: V -> V)<std/core/types/string>))
               -> "";
            ((.skip std/core/Cons((x0: std/core/types/string) : std/core/types/string, (xx0: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string> ) as .pat21: ((std/core/list :: V -> V)<std/core/types/string>))
               -> std/core/.lift17201-reverse-join(xx0, x0);
          });
        }))((std/core/Cons<std/core/types/string>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(matched : (std/core/list :: V -> V)<std/core/sslice>) -> std/core/types/string,(matched : (std/core/list :: V -> V)<std/core/sslice>) -> (e :: E) std/core/types/string>((fn(matched1: (std/core/list :: V -> V)<std/core/sslice>){
            (match (matched1) {
              ((std/core/Cons(((.skip std/core/Sslice((.pat01: std/core/types/string) : std/core/types/string, (.pat12: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat22: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as s0: std/core/sslice) : std/core/sslice, (.pat30: (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice> ) as .pat5: ((std/core/list :: V -> V)<std/core/sslice>))
                 -> std/core/string.3(s0);
              ((.skip std/core/Nil() : (std/core/list :: V -> V)<std/core/sslice> ) as .pat40: ((std/core/list :: V -> V)<std/core/sslice>))
                 -> "";
            });
          }))(post)), acc)));
      ((.skip std/core/Nil() : (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>> ) as .pat31: ((std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>))
         -> std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (std/core/list :: V -> V)<std/core/types/string>) -> std/core/types/string,(xs : (std/core/list :: V -> V)<std/core/types/string>) -> (e :: E) std/core/types/string>((fn(xs0: (std/core/list :: V -> V)<std/core/types/string>){
          val xs0.171510 : ((std/core/list :: V -> V)<std/core/types/string>)
                = (std/core/.lift17200-reverse-join<std/core/types/string>((std/core/Nil<std/core/types/string>), xs0));
          (match (xs0.171510) {
            ((std/core/Nil() : (std/core/list :: V -> V)<std/core/types/string> ) as .pat101: ((std/core/list :: V -> V)<std/core/types/string>))
               -> "";
            ((.skip std/core/Cons((x00: std/core/types/string) : std/core/types/string, (xx00: (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string>) : (std/core/list :: V -> V)<std/core/types/string> ) as .pat23: ((std/core/list :: V -> V)<std/core/types/string>))
               -> std/core/.lift17201-reverse-join(xx00, x00);
          });
        }))(acc);
    });
  };
specialize "__*" fun replace // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(s: std/core/types/string, r: regex, repl: ((std/core/list :: V -> V)<std/core/sslice>) -> (e :: E) std/core/types/string){
    std/text/regex/replace-all<(e :: E)>(s, r, repl, (std/core/types/Optional<std/core/types/int>(1)));
  };
specialize "__*_" fun replace-all // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(s: std/core/types/string, r: regex, repl: ((std/core/list :: V -> V)<std/core/sslice>) -> (e :: E) std/core/types/string, atmost: (std/core/types/optional :: V -> V)<std/core/types/int>){
    std/text/regex/concat-replace<(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(regex : regex, s : std/core/types/string, atmost : (std/core/types/optional :: V -> V)<std/core/types/int>) -> (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>,(regex : regex, s : std/core/types/string, atmost : (std/core/types/optional :: V -> V)<std/core/types/int>) -> (e :: E) (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>>((fn(regex0: regex, s0: std/core/types/string, atmost0: (std/core/types/optional :: V -> V)<std/core/types/int>){
        (std/text/regex/regex-exec-all((match (regex0) {
            ((.skip std/text/regex/Regex((.x: std/core/types/any) : std/core/types/any, (.pat0: std/core/types/string) : std/core/types/string) : regex ) as .pat: regex)
               -> .x;
          }), s0, (std/core/ssize_t(0)), (std/core/ssize_t((match (atmost0) {
            ((std/core/types/Optional((.atmost.345: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat1: ((std/core/types/optional :: V -> V)<std/core/types/int>))
               -> .atmost.345;
            ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat00: ((std/core/types/optional :: V -> V)<std/core/types/int>))
               -> -1;
          })))));
      }))(r, s, (std/core/types/Optional<std/core/types/int>((match (atmost) {
          ((std/core/types/Optional((.atmost.475: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> .atmost.475;
          ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat01: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> -1;
        }))))), repl, (std/core/Nil<std/core/types/string>));
  };
specialize "__*_" fun replace-all.1 // inline size: 1
  = fn(s: std/core/types/string, regex0: regex, repl: std/core/types/string, atmost: (std/core/types/optional :: V -> V)<std/core/types/int>){
    match ((std/core/contains(repl, "$"))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/text/regex/replace-all<(std/core/types/(<>) :: E)>(s, regex0, (fn(caps: (std/core/list :: V -> V)<std/core/sslice>){
            (std/text/regex/replace-captures(caps, repl));
          }), (std/core/types/Optional<std/core/types/int>((match (atmost) {
            ((std/core/types/Optional((.atmost.496: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
               -> .atmost.496;
            ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
               -> -1;
          }))));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
         -> std/text/regex/replace-all<(std/core/types/(<>) :: E)>(s, regex0, (fn(._wildcard_158_35: (std/core/list :: V -> V)<std/core/sslice>){
            repl;
          }), (std/core/types/Optional<std/core/types/int>((match (atmost) {
            ((std/core/types/Optional((.atmost.496: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
               -> .atmost.496;
            ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
               -> -1;
          }))));
    };
  };
specialize "*_" fun replace-captures // inline size: 1
  = fn(caps: (std/core/list :: V -> V)<std/core/sslice>, repl: std/core/types/string){
    std/text/regex/replace-all<(std/core/types/(<>) :: E)>(repl, (std/text/regex/Regex((std/text/regex/regex-create("\x5C$(?:(\x5Cd)|(\x5C&)|(\x5C$))", (match ((std/core/types/None<std/core/types/bool>)) {
            ((std/core/types/Optional((.ignorecase.455: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
               -> .ignorecase.455;
            ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
               -> std/core/types/False;
          }), (match ((std/core/types/None<std/core/types/bool>)) {
            ((std/core/types/Optional((.multiline.459: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat1: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
               -> .multiline.459;
            ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
               -> std/core/types/False;
          }))), "\x5C$(?:(\x5Cd)|(\x5C&)|(\x5C$))")), (fn(cap: (std/core/list :: V -> V)<std/core/sslice>){
        (match (cap) {
          ((std/core/Cons(((.skip std/core/Sslice((.pat10: std/core/types/string) : std/core/types/string, (.pat20: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat30: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as .pat00: std/core/sslice) : std/core/sslice, ((std/core/Cons(((.skip std/core/Sslice((.pat5: std/core/types/string) : std/core/types/string, (.pat6: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat7: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as digit: std/core/sslice) : std/core/sslice, ((std/core/Cons(((.skip std/core/Sslice((.pat9: std/core/types/string) : std/core/types/string, (.pat100: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat11: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as amp: std/core/sslice) : std/core/sslice, ((std/core/Cons(((.skip std/core/Sslice((.pat13: std/core/types/string) : std/core/types/string, (.pat14: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat15: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as dollar: std/core/sslice) : std/core/sslice, ((std/core/Nil() : (std/core/list :: V -> V)<std/core/sslice> ) as .pat16: (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice> ) as .pat12: (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice> ) as .pat8: (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice> ) as .pat4: (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice> ) as .pat3: ((std/core/list :: V -> V)<std/core/sslice>))
             -> (match ((std/core/(>=.2)((match (dollar) {
                ((.skip std/core/Sslice((.pat01: std/core/types/string) : std/core/types/string, (.x: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat18: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as .pat17: std/core/sslice)
                   -> .x;
              }), (std/core/ssize_t(0))))) {
              ((std/core/types/True() : std/core/types/bool ) as .pat170: std/core/types/bool)
                 -> "$";
              ((.skip std/core/types/False() : std/core/types/bool ) as .pat180: std/core/types/bool)
                 -> val grp : std/core/types/int
                          = (match ((std/core/(>=.2)((match (amp) {
                              ((.skip std/core/Sslice((.pat02: std/core/types/string) : std/core/types/string, (.x0: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat110: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as .pat19: std/core/sslice)
                                 -> .x0;
                            }), (std/core/ssize_t(0))))) {
                            ((std/core/types/True() : std/core/types/bool ) as .pat190: std/core/types/bool)
                               -> 0;
                            ((.skip std/core/types/False() : std/core/types/bool ) as .pat200: std/core/types/bool)
                               -> std/core/parse-int-default((std/core/string.3(digit)), (std/core/types/Optional<std/core/types/int>(0)), (std/core/types/None<std/core/types/bool>));
                          });
                (match ((std/core/([].2)<std/core/sslice>(caps, grp))) {
                  ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<std/core/sslice> ) as .pat21: ((std/core/types/maybe :: V -> V)<std/core/sslice>))
                     -> "";
                  ((.skip std/core/types/Just(((.skip std/core/Sslice((.pat23: std/core/types/string) : std/core/types/string, (.pat24: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat25: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as s: std/core/sslice) : std/core/sslice) : (std/core/types/maybe :: V -> V)<std/core/sslice> ) as .pat22: ((std/core/types/maybe :: V -> V)<std/core/sslice>))
                     -> std/core/string.3(s);
                });
            });
          (.pat26: ((std/core/list :: V -> V)<std/core/sslice>))
             -> "$";
        });
      }), (std/core/types/None<std/core/types/int>));
  };
specialize "__*" fun replace.1 // inline size: 1
  = fn(s: std/core/types/string, regex0: regex, repl: std/core/types/string){
    match ((std/core/contains(repl, "$"))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/text/regex/replace-all<(std/core/types/(<>) :: E)>(s, regex0, (fn(caps: (std/core/list :: V -> V)<std/core/sslice>){
            (std/text/regex/replace-captures(caps, repl));
          }), (std/core/types/Optional<std/core/types/int>(1)));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
         -> std/text/regex/replace-all<(std/core/types/(<>) :: E)>(s, regex0, (fn(._wildcard_158_35: (std/core/list :: V -> V)<std/core/sslice>){
            repl;
          }), (std/core/types/Optional<std/core/types/int>(1)));
    };
  };
inline borrow "^" fun obj // inline size: 0
  = fn(regex0: regex){
    match (regex0) {
      ((.skip std/text/regex/Regex((.x: std/core/types/any) : std/core/types/any, (.pat0: std/core/types/string) : std/core/types/string) : regex ) as .pat: regex)
         -> .x;
    };
  };
inline borrow "^" fun src // inline size: 0
  = fn(regex0: regex){
    match (regex0) {
      ((.skip std/text/regex/Regex((.pat0: std/core/types/any) : std/core/types/any, (.x: std/core/types/string) : std/core/types/string) : regex ) as .pat: regex)
         -> .x;
    };
  };
fun .copy // inline size: 3
  = fn(.this: regex, obj0: (std/core/types/optional :: V -> V)<std/core/types/any>, src0: (std/core/types/optional :: V -> V)<std/core/types/string>){
    std/text/regex/Regex((match (obj0) {
        ((std/core/types/Optional((.obj.104: std/core/types/any) : std/core/types/any) : (std/core/types/optional :: V -> V)<std/core/types/any> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/any>))
           -> .obj.104;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/any> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/any>))
           -> (match (.this) {
            ((.skip std/text/regex/Regex((.x: std/core/types/any) : std/core/types/any, (.pat00: std/core/types/string) : std/core/types/string) : regex ) as .pat1: regex)
               -> .x;
          });
      }), (match (src0) {
        ((std/core/types/Optional((.src.110: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat10: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> .src.110;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> (match (.this) {
            ((.skip std/text/regex/Regex((.pat01: std/core/types/any) : std/core/types/any, (.x0: std/core/types/string) : std/core/types/string) : regex ) as .pat3: regex)
               -> .x0;
          });
      }));
  };
fun captured // inline size: 2
  = fn(matched0: (std/core/list :: V -> V)<std/core/sslice>){
    match (matched0) {
      ((std/core/Cons(((.skip std/core/Sslice((.pat0: std/core/types/string) : std/core/types/string, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat2: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as s: std/core/sslice) : std/core/sslice, (.pat3: (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice> ) as .pat: ((std/core/list :: V -> V)<std/core/sslice>))
         -> std/core/string.3(s);
      ((.skip std/core/Nil() : (std/core/list :: V -> V)<std/core/sslice> ) as .pat4: ((std/core/list :: V -> V)<std/core/sslice>))
         -> "";
    };
  };
inline fun source // inline size: 0
  = fn(r: regex){
    match (r) {
      ((.skip std/text/regex/Regex((.pat0: std/core/types/any) : std/core/types/any, (.x: std/core/types/string) : std/core/types/string) : regex ) as .pat: regex)
         -> .x;
    };
  };
fun matched // inline size: 2
  = fn(s: std/core/sslice){
    std/core/(>=.2)((match (s) {
        ((.skip std/core/Sslice((.pat0: std/core/types/string) : std/core/types/string, (.x: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t) : std/core/sslice ) as .pat: std/core/sslice)
           -> .x;
      }), (std/core/ssize_t(0)));
  };
fun captures // inline size: 1
  = fn(xs: (std/core/list :: V -> V)<(std/core/list :: V -> V)<std/core/sslice>>){
    std/core/map.5<(std/core/list :: V -> V)<std/core/sslice>,std/core/types/string,(std/core/types/(<>) :: E)>(xs, std/text/regex/captured);
  };
fun exec // inline size: 2
  = fn(regex0: regex, s: std/core/types/string){
    std/text/regex/regex-exec((match (regex0) {
        ((.skip std/text/regex/Regex((.x: std/core/types/any) : std/core/types/any, (.pat0: std/core/types/string) : std/core/types/string) : regex ) as .pat: regex)
           -> .x;
      }), s, (std/core/ssize_t(0)));
  };
fun contains // inline size: 3
  = fn(s: std/core/types/string, r: regex){
    val list0.968 : (std/core/list :: V -> V)<std/core/sslice>
          = std/text/regex/regex-exec((match (r) {
              ((.skip std/text/regex/Regex((.x: std/core/types/any) : std/core/types/any, (.pat00: std/core/types/string) : std/core/types/string) : regex ) as .pat3: regex)
                 -> .x;
            }), s, (std/core/ssize_t(0)));
    match (list0.968) {
      ((std/core/Cons((.pat0: std/core/sslice) : std/core/sslice, (.pat1: (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice>) : (std/core/list :: V -> V)<std/core/sslice> ) as .pat: ((std/core/list :: V -> V)<std/core/sslice>))
         -> std/core/types/True;
      ((.skip std/core/Nil() : (std/core/list :: V -> V)<std/core/sslice> ) as .pat2: ((std/core/list :: V -> V)<std/core/sslice>))
         -> std/core/types/False;
    };
  };
fun exec-all // inline size: 4
  = fn(regex0: regex, s: std/core/types/string, atmost: (std/core/types/optional :: V -> V)<std/core/types/int>){
    std/text/regex/regex-exec-all((match (regex0) {
        ((.skip std/text/regex/Regex((.x: std/core/types/any) : std/core/types/any, (.pat0: std/core/types/string) : std/core/types/string) : regex ) as .pat: regex)
           -> .x;
      }), s, (std/core/ssize_t(0)), (std/core/ssize_t((match (atmost) {
        ((std/core/types/Optional((.atmost.345: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat1: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .atmost.345;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat00: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> -1;
      }))));
  };
fun regex // inline size: 4
  = fn(regex0: std/core/types/string, ignorecase: (std/core/types/optional :: V -> V)<std/core/types/bool>, multiline: (std/core/types/optional :: V -> V)<std/core/types/bool>){
    std/text/regex/Regex((std/text/regex/regex-create(regex0, (match (ignorecase) {
          ((std/core/types/Optional((.ignorecase.455: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
             -> .ignorecase.455;
          ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
             -> std/core/types/False;
        }), (match (multiline) {
          ((std/core/types/Optional((.multiline.459: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat1: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
             -> .multiline.459;
          ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
             -> std/core/types/False;
        }))), regex0);
  };
fun replace // inline size: 2
  = forall<(e :: E)> fn<(e :: E)>(s: std/core/types/string, r: regex, repl: ((std/core/list :: V -> V)<std/core/sslice>) -> (e :: E) std/core/types/string){
    std/text/regex/replace-all<(e :: E)>(s, r, repl, (std/core/types/Optional<std/core/types/int>(1)));
  };