/* Date, clock, and week days support.

   Defines basic types for human readable time. Years, months, days etc. are always 1-based.
   Week dates are absent as they are treated as normal dates, using the `std/time/calendars/cal-iso-week` calendar.
*/
module interface std/time/date
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core = std/core = "";
import std/num/float64 = std/num/float64 = "";
import std/num/ddouble = std/num/ddouble = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 
// A clock consists of the hour, minute, second, and fractional second (between ``0.0` and `1.0`).
pub type clock {
  // A clock consists of the hour, minute, second, and fractional second (between ``0.0` and `1.0`).
  pub con Clock(hours: std/core/types/int, minutes: std/core/types/int, seconds: std/num/ddouble/ddouble) : (hours : std/core/types/int, minutes : std/core/types/int, seconds : std/num/ddouble/ddouble) -> clock;
};
// A date consists of a the year, month, and day.
pub value{0,3} type date {
  // A date consists of a the year, month, and day.
  pub con Date(year: std/core/types/int, month: std/core/types/int, day: std/core/types/int) : (year : std/core/types/int, month : std/core/types/int, day : std/core/types/int) -> date;
};
// An ISO day of the week, starting at Monday (=1) up to Sunday (=7).
pub value{1,0} type weekday {
  pub con Mon : weekday;
  pub con Tue : weekday;
  pub con Wed : weekday;
  pub con Thu : weekday;
  pub con Fri : weekday;
  pub con Sat : weekday;
  pub con Sun : weekday;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `hours` constructor field of the `:clock` type.
pub fun hours : (^ clock : clock) -> std/core/types/int;
// Automatically generated. Retrieves the `minutes` constructor field of the `:clock` type.
pub fun minutes : (^ clock : clock) -> std/core/types/int;
// Automatically generated. Retrieves the `seconds` constructor field of the `:clock` type.
pub fun seconds : (^ clock : clock) -> std/num/ddouble/ddouble;
pub fun .copy : (.this : clock, hours : (std/core/types/optional :: V -> V)<std/core/types/int>, minutes : (std/core/types/optional :: V -> V)<std/core/types/int>, seconds : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>) -> clock;
// Automatically generated. Retrieves the `year` constructor field of the `:date` type.
pub fun year : (^ date : date) -> std/core/types/int;
// Automatically generated. Retrieves the `month` constructor field of the `:date` type.
pub fun month : (^ date : date) -> std/core/types/int;
// Automatically generated. Retrieves the `day` constructor field of the `:date` type.
pub fun day : (^ date : date) -> std/core/types/int;
pub fun .copy.1 : (.this : date, year : (std/core/types/optional :: V -> V)<std/core/types/int>, month : (std/core/types/optional :: V -> V)<std/core/types/int>, day : (std/core/types/optional :: V -> V)<std/core/types/int>) -> date;
// Automatically generated. Tests for the `Mon` constructor of the `:weekday` type.
pub fun is-mon : (^ weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Tue` constructor of the `:weekday` type.
pub fun is-tue : (^ weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Wed` constructor of the `:weekday` type.
pub fun is-wed : (^ weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Thu` constructor of the `:weekday` type.
pub fun is-thu : (^ weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Fri` constructor of the `:weekday` type.
pub fun is-fri : (^ weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Sat` constructor of the `:weekday` type.
pub fun is-sat : (^ weekday : weekday) -> std/core/types/bool;
// Automatically generated. Tests for the `Sun` constructor of the `:weekday` type.
pub fun is-sun : (^ weekday : weekday) -> std/core/types/bool;
// Convert a `:weekday` to an `:int` using the ISO definition which starts at Monday as 1,
// up to Sunday as 7.
pub fun int : (wd : weekday) -> std/core/types/int;
// Add two dates field-wise together.
pub fun (+) : (d1 : date, d2 : date) -> date;
// Add two clock together.
pub fun (+.1) : (c : clock, d : clock) -> clock;
// Convert a weekday number to a `:weekday`(starting at Monday (=1) up to Sunday (=7)).
// Takes the integer `i - 1` modulo 7, so `0` or `14` also become Sunday etc.
pub fun weekday : (i : std/core/types/int) -> weekday;
// Return the `:weekday` that comes `n` days after week day `wd`.
pub fun (+.2) : (wd : weekday, n : std/core/types/int) -> weekday;
// Return the `:weekday` that comes `n` days before week day `wd`.
pub fun (-) : (wd : weekday, n : std/core/types/int) -> weekday;
// Return the difference between two week days:\
// `wd2 == wd1 + (wd2 - wd1)`
pub fun (-.1) : (wd1 : weekday, wd2 : weekday) -> std/core/types/int;
// Compare two dates by fields.
pub fun compare : (d : date, e : date) -> std/core/types/order;
pub fun (==) : (i : date, j : date) -> std/core/types/bool;
// Return the total seconds of a `:clock` assuming 60 seconds per
// minute and 60 minutes per hour.
pub fun total-seconds : (c : clock) -> std/num/ddouble/ddouble;
// Compare two clocks as by their total seconds.
pub fun compare.1 : (c : clock, d : clock) -> std/core/types/order;
pub fun (==.1) : (i : clock, j : clock) -> std/core/types/bool;
// Compare weekdays.
pub fun compare.2 : (wd1 : weekday, wd2 : weekday) -> std/core/types/order;
pub fun (==.2) : (i : weekday, j : weekday) -> std/core/types/bool;
// Create a clock from a seconds as an `:int` with an optional fraction.
// Normalizes the clock with seconds and minutes under 60 but
// adds the fraction as is to the final seconds, so that might
// be `>= 60` if the fraction `>= 1.0`;
pub fun clock.2 : (seconds : std/core/types/int, frac : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>) -> clock;
// Create a clock from seconds; normalizes the clock with seconds and minutes under 60.
pub fun clock : (seconds : std/num/ddouble/ddouble) -> clock;
// Create a clock from a seconds as an `:int` with an optional fraction.
// Normalizes the clock with seconds and minutes under 60 but
// adds the fraction as is to the final seconds, so that might
// be `>= 60` if the fraction `>= 1.0`;
pub fun clock.1 : (seconds : std/core/types/int, frac : std/core/types/float64) -> clock;
pub fun clock.3 : (seconds : std/num/ddouble/ddouble, leap : std/core/types/int) -> clock;
pub fun (!=) : (i : date, j : date) -> std/core/types/bool;
pub fun (!=.1) : (i : clock, j : clock) -> std/core/types/bool;
pub fun (!=.2) : (i : weekday, j : weekday) -> std/core/types/bool;
pub fun (<) : (i : date, j : date) -> std/core/types/bool;
pub fun (<.1) : (i : clock, j : clock) -> std/core/types/bool;
pub fun (<.2) : (i : weekday, j : weekday) -> std/core/types/bool;
pub fun (<=) : (i : date, j : date) -> std/core/types/bool;
pub fun (<=.1) : (i : clock, j : clock) -> std/core/types/bool;
pub fun (<=.2) : (i : weekday, j : weekday) -> std/core/types/bool;
pub fun (>) : (i : date, j : date) -> std/core/types/bool;
pub fun (>.1) : (i : clock, j : clock) -> std/core/types/bool;
pub fun (>.2) : (i : weekday, j : weekday) -> std/core/types/bool;
pub fun (>=) : (i : date, j : date) -> std/core/types/bool;
pub fun (>=.1) : (i : clock, j : clock) -> std/core/types/bool;
pub fun (>=.2) : (i : weekday, j : weekday) -> std/core/types/bool;
// The zero clock
pub val clock0 : clock;
// Return the ISO calendar date of Easter in a given year (Algorithm by [J.M. Oudin](http://aa.usno.navy.mil/faq/docs/easter.php)).
pub fun easter : (year : std/core/types/int) -> date;
// Is this a zero clock?
pub fun is-zero : (c : clock) -> std/core/types/bool;
// Return the fraction of the seconds as milli-seconds (10^-3^).
pub fun milli-seconds : (c : clock) -> std/core/types/int;
// Return the fraction of seconds as nano-seconds ((10^-9^).
pub fun nano-seconds : (c : clock) -> std/core/types/int;
// Round a clock time to a certain number of digits precision (of the fraction of seconds) (default `9`, nano seconds).
pub fun round-to-prec : (c : clock, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> clock;
// Show seconds
pub fun show-seconds : (secs : std/num/ddouble/ddouble, max-prec : (std/core/types/optional :: V -> V)<std/core/types/int>, secs-width : (std/core/types/optional :: V -> V)<std/core/types/int>, unit : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
// pad with zeros
fun show0 : (i : std/core/types/int, width : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// Show a year in ISO format (using 5+ digits and explicit sign for years < 0 or years > 9999)).
pub fun show-year : (year : std/core/types/int) -> std/core/types/string;
// Show a date in ISO format. `Date(2000,1,1).show == "2000-01-01"`.
// Takes an optional `month-prefix` (=`""`) that is used by the ISO week
// and month calendar to add a `"W"` or `"M"` prefix respectively.
pub fun show : (d : date, month-prefix : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Show a clock in ISO format up to an optional maximum precision (=`9`).\
// `Clock(23,30,fixed(1.123)).show == "23:30:01.123"`\
// `Clock(23,30,fixed(1.123)).show(0) == "23:30:01"`
pub fun show.1 : (c : clock, prec : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// Show a `:weekday` as an English string (`Sun.show == "Sunday"`).
pub fun show.2 : (wd : weekday) -> std/core/types/string;
// Show a `:weekday` as a 3 letter English string (`Sun.show-short == "Sun"`)
pub fun show-short : (wd : weekday) -> std/core/types/string;
// Create an ISO weekdate where the "month" is the ISO week number.
pub fun weekdate : (year : std/core/types/int, month : std/core/types/int, weekday : weekday) -> date;
// Return the whole seconds part of a `:clock`.
pub fun whole-seconds : (c : clock) -> std/core/types/int;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^" fun hours // inline size: 0
  = fn(clock1: clock){
    match (clock1) {
      ((.skip std/time/date/Clock((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/float64) : std/core/types/float64, (.pat3: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .pat1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat: clock)
         -> .x;
    };
  };
inline borrow "^" fun minutes // inline size: 0
  = fn(clock1: clock){
    match (clock1) {
      ((.skip std/time/date/Clock((.pat0: std/core/types/int) : std/core/types/int, (.x: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/float64) : std/core/types/float64, (.pat3: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .pat1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat: clock)
         -> .x;
    };
  };
inline borrow "^" fun seconds // inline size: 0
  = fn(clock1: clock){
    match (clock1) {
      ((.skip std/time/date/Clock((.pat0: std/core/types/int) : std/core/types/int, (.pat1: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/float64) : std/core/types/float64, (.pat3: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .x: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat: clock)
         -> .x;
    };
  };
fun .copy // inline size: 4
  = fn(.this: clock, hours0: (std/core/types/optional :: V -> V)<std/core/types/int>, minutes0: (std/core/types/optional :: V -> V)<std/core/types/int>, seconds0: (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>){
    std/time/date/Clock((match (hours0) {
        ((std/core/types/Optional((.hours.97: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .hours.97;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> (match (.this) {
            ((.skip std/time/date/Clock((.x: std/core/types/int) : std/core/types/int, (.pat00: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/float64) : std/core/types/float64, (.pat3: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .pat10: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat1: clock)
               -> .x;
          });
      }), (match (minutes0) {
        ((std/core/types/Optional((.minutes.103: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat11: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .minutes.103;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat20: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> (match (.this) {
            ((.skip std/time/date/Clock((.pat01: std/core/types/int) : std/core/types/int, (.x0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat21: std/core/types/float64) : std/core/types/float64, (.pat30: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .pat12: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat4: clock)
               -> .x0;
          });
      }), (match (seconds0) {
        ((std/core/types/Optional((.seconds.109: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble> ) as .pat31: ((std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>))
           -> .seconds.109;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/num/ddouble/ddouble> ) as .pat40: ((std/core/types/optional :: V -> V)<std/num/ddouble/ddouble>))
           -> (match (.this) {
            ((.skip std/time/date/Clock((.pat02: std/core/types/int) : std/core/types/int, (.pat13: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat22: std/core/types/float64) : std/core/types/float64, (.pat32: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .x1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat5: clock)
               -> .x1;
          });
      }));
  };
inline borrow "^" fun year // inline size: 0
  = fn(date: date){
    match (date) {
      ((.skip std/time/date/Date((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, (.pat1: std/core/types/int) : std/core/types/int) : date ) as .pat: date)
         -> .x;
    };
  };
inline borrow "^" fun month // inline size: 0
  = fn(date: date){
    match (date) {
      ((.skip std/time/date/Date((.pat0: std/core/types/int) : std/core/types/int, (.x: std/core/types/int) : std/core/types/int, (.pat1: std/core/types/int) : std/core/types/int) : date ) as .pat: date)
         -> .x;
    };
  };
inline borrow "^" fun day // inline size: 0
  = fn(date: date){
    match (date) {
      ((.skip std/time/date/Date((.pat0: std/core/types/int) : std/core/types/int, (.pat1: std/core/types/int) : std/core/types/int, (.x: std/core/types/int) : std/core/types/int) : date ) as .pat: date)
         -> .x;
    };
  };
fun .copy.1 // inline size: 4
  = fn(.this: date, year0: (std/core/types/optional :: V -> V)<std/core/types/int>, month0: (std/core/types/optional :: V -> V)<std/core/types/int>, day0: (std/core/types/optional :: V -> V)<std/core/types/int>){
    std/time/date/Date((match (year0) {
        ((std/core/types/Optional((.year.143: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .year.143;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> (match (.this) {
            ((.skip std/time/date/Date((.x: std/core/types/int) : std/core/types/int, (.pat00: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int) : date ) as .pat1: date)
               -> .x;
          });
      }), (match (month0) {
        ((std/core/types/Optional((.month.149: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat11: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .month.149;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> (match (.this) {
            ((.skip std/time/date/Date((.pat01: std/core/types/int) : std/core/types/int, (.x0: std/core/types/int) : std/core/types/int, (.pat12: std/core/types/int) : std/core/types/int) : date ) as .pat3: date)
               -> .x0;
          });
      }), (match (day0) {
        ((std/core/types/Optional((.day.155: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat30: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .day.155;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat4: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> (match (.this) {
            ((.skip std/time/date/Date((.pat02: std/core/types/int) : std/core/types/int, (.pat13: std/core/types/int) : std/core/types/int, (.x1: std/core/types/int) : std/core/types/int) : date ) as .pat5: date)
               -> .x1;
          });
      }));
  };
inline borrow "^" fun is-mon // inline size: 1
  = fn(weekday0: weekday){
    match (weekday0) {
      ((std/time/date/Mon() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-tue // inline size: 1
  = fn(weekday0: weekday){
    match (weekday0) {
      ((std/time/date/Tue() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-wed // inline size: 1
  = fn(weekday0: weekday){
    match (weekday0) {
      ((std/time/date/Wed() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-thu // inline size: 1
  = fn(weekday0: weekday){
    match (weekday0) {
      ((std/time/date/Thu() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-fri // inline size: 1
  = fn(weekday0: weekday){
    match (weekday0) {
      ((std/time/date/Fri() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-sat // inline size: 1
  = fn(weekday0: weekday){
    match (weekday0) {
      ((std/time/date/Sat() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-sun // inline size: 1
  = fn(weekday0: weekday){
    match (weekday0) {
      ((std/time/date/Sun() : weekday ) as .pat: weekday)
         -> std/core/types/True;
      (.pat0: weekday)
         -> std/core/types/False;
    };
  };
fun (+) // inline size: 4
  = fn(d1: date, d2: date){
    std/time/date/Date((std/core/int-add((match (d1) {
          ((.skip std/time/date/Date((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, (.pat1: std/core/types/int) : std/core/types/int) : date ) as .pat: date)
             -> .x;
        }), (match (d2) {
          ((.skip std/time/date/Date((.x0: std/core/types/int) : std/core/types/int, (.pat00: std/core/types/int) : std/core/types/int, (.pat10: std/core/types/int) : std/core/types/int) : date ) as .pat2: date)
             -> .x0;
        }))), (std/core/int-add((match (d1) {
          ((.skip std/time/date/Date((.pat01: std/core/types/int) : std/core/types/int, (.x1: std/core/types/int) : std/core/types/int, (.pat11: std/core/types/int) : std/core/types/int) : date ) as .pat3: date)
             -> .x1;
        }), (match (d2) {
          ((.skip std/time/date/Date((.pat02: std/core/types/int) : std/core/types/int, (.x2: std/core/types/int) : std/core/types/int, (.pat12: std/core/types/int) : std/core/types/int) : date ) as .pat4: date)
             -> .x2;
        }))), (std/core/int-add((match (d1) {
          ((.skip std/time/date/Date((.pat03: std/core/types/int) : std/core/types/int, (.pat13: std/core/types/int) : std/core/types/int, (.x3: std/core/types/int) : std/core/types/int) : date ) as .pat5: date)
             -> .x3;
        }), (match (d2) {
          ((.skip std/time/date/Date((.pat04: std/core/types/int) : std/core/types/int, (.pat14: std/core/types/int) : std/core/types/int, (.x4: std/core/types/int) : std/core/types/int) : date ) as .pat6: date)
             -> .x4;
        }))));
  };
fun (+.1) // inline size: 4
  = fn(c: clock, d: clock){
    std/time/date/Clock((std/core/int-add((match (c) {
          ((.skip std/time/date/Clock((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/float64) : std/core/types/float64, (.pat3: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .pat1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat: clock)
             -> .x;
        }), (match (d) {
          ((.skip std/time/date/Clock((.x0: std/core/types/int) : std/core/types/int, (.pat00: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat20: std/core/types/float64) : std/core/types/float64, (.pat30: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .pat10: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat4: clock)
             -> .x0;
        }))), (std/core/int-add((match (c) {
          ((.skip std/time/date/Clock((.pat01: std/core/types/int) : std/core/types/int, (.x1: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat21: std/core/types/float64) : std/core/types/float64, (.pat31: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .pat11: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat5: clock)
             -> .x1;
        }), (match (d) {
          ((.skip std/time/date/Clock((.pat02: std/core/types/int) : std/core/types/int, (.x2: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat22: std/core/types/float64) : std/core/types/float64, (.pat32: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .pat12: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat6: clock)
             -> .x2;
        }))), (std/num/ddouble/(+)((match (c) {
          ((.skip std/time/date/Clock((.pat03: std/core/types/int) : std/core/types/int, (.pat13: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat23: std/core/types/float64) : std/core/types/float64, (.pat33: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .x3: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat7: clock)
             -> .x3;
        }), (match (d) {
          ((.skip std/time/date/Clock((.pat04: std/core/types/int) : std/core/types/int, (.pat14: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat24: std/core/types/float64) : std/core/types/float64, (.pat34: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .x4: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat8: clock)
             -> .x4;
        }))));
  };
fun (+.2) // inline size: 3
  = fn(wd: weekday, n: std/core/types/int){
    val x.5622 : std/core/types/int
          = std/time/date/int(wd);
    std/time/date/weekday((std/core/int-add(x.5622, n)));
  };
fun (-) // inline size: 3
  = fn(wd: weekday, n: std/core/types/int){
    val x.5624 : std/core/types/int
          = std/time/date/int(wd);
    std/time/date/weekday((std/core/int-sub(x.5624, n)));
  };
fun (-.1) // inline size: 4
  = fn(wd1: weekday, wd2: weekday){
    val x.5626 : std/core/types/int
      = std/time/date/int(wd1);
    val y.5627 : std/core/types/int
      = std/time/date/int(wd2);
    std/core/(%)((std/core/int-sub(x.5626, y.5627)), 7);
  };
fun (==) // inline size: 2
  = fn(i: date, j: date){
    std/core/(==.4)((std/time/date/compare(i, j)), std/core/types/Eq);
  };
fun (==.1) // inline size: 2
  = fn(i: clock, j: clock){
    std/core/(==.4)((std/time/date/compare.1(i, j)), std/core/types/Eq);
  };
fun compare.2 // inline size: 3
  = fn(wd1: weekday, wd2: weekday){
    std/core/compare((std/time/date/int(wd1)), (std/time/date/int(wd2)));
  };
fun (==.2) // inline size: 4
  = fn(i: weekday, j: weekday){
    std/core/(==.4)((std/core/compare((std/time/date/int(i)), (std/time/date/int(j)))), std/core/types/Eq);
  };
fun (!=) // inline size: 2
  = fn(i: date, j: date){
    std/core/(!=.4)((std/time/date/compare(i, j)), std/core/types/Eq);
  };
fun (!=.1) // inline size: 2
  = fn(i: clock, j: clock){
    std/core/(!=.4)((std/time/date/compare.1(i, j)), std/core/types/Eq);
  };
fun (!=.2) // inline size: 4
  = fn(i: weekday, j: weekday){
    std/core/(!=.4)((std/core/compare((std/time/date/int(i)), (std/time/date/int(j)))), std/core/types/Eq);
  };
fun (<) // inline size: 2
  = fn(i: date, j: date){
    std/core/(==.4)((std/time/date/compare(i, j)), std/core/types/Lt);
  };
fun (<.1) // inline size: 2
  = fn(i: clock, j: clock){
    std/core/(==.4)((std/time/date/compare.1(i, j)), std/core/types/Lt);
  };
fun (<.2) // inline size: 4
  = fn(i: weekday, j: weekday){
    std/core/(==.4)((std/core/compare((std/time/date/int(i)), (std/time/date/int(j)))), std/core/types/Lt);
  };
fun (<=) // inline size: 2
  = fn(i: date, j: date){
    std/core/(!=.4)((std/time/date/compare(i, j)), std/core/types/Gt);
  };
fun (<=.1) // inline size: 2
  = fn(i: clock, j: clock){
    std/core/(!=.4)((std/time/date/compare.1(i, j)), std/core/types/Gt);
  };
fun (<=.2) // inline size: 4
  = fn(i: weekday, j: weekday){
    std/core/(!=.4)((std/core/compare((std/time/date/int(i)), (std/time/date/int(j)))), std/core/types/Gt);
  };
fun (>) // inline size: 2
  = fn(i: date, j: date){
    std/core/(==.4)((std/time/date/compare(i, j)), std/core/types/Gt);
  };
fun (>.1) // inline size: 2
  = fn(i: clock, j: clock){
    std/core/(==.4)((std/time/date/compare.1(i, j)), std/core/types/Gt);
  };
fun (>.2) // inline size: 4
  = fn(i: weekday, j: weekday){
    std/core/(==.4)((std/core/compare((std/time/date/int(i)), (std/time/date/int(j)))), std/core/types/Gt);
  };
fun (>=) // inline size: 2
  = fn(i: date, j: date){
    std/core/(!=.4)((std/time/date/compare(i, j)), std/core/types/Lt);
  };
fun (>=.1) // inline size: 2
  = fn(i: clock, j: clock){
    std/core/(!=.4)((std/time/date/compare.1(i, j)), std/core/types/Lt);
  };
fun (>=.2) // inline size: 4
  = fn(i: weekday, j: weekday){
    std/core/(!=.4)((std/core/compare((std/time/date/int(i)), (std/time/date/int(j)))), std/core/types/Lt);
  };
fun round-to-prec // inline size: 3
  = fn(c: clock, prec: (std/core/types/optional :: V -> V)<std/core/types/int>){
    std/time/date/Clock((match (c) {
        ((.skip std/time/date/Clock((.x: std/core/types/int) : std/core/types/int, (.pat0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat2: std/core/types/float64) : std/core/types/float64, (.pat3: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .pat1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat: clock)
           -> .x;
      }), (match (c) {
        ((.skip std/time/date/Clock((.pat00: std/core/types/int) : std/core/types/int, (.x0: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat20: std/core/types/float64) : std/core/types/float64, (.pat30: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .pat10: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat4: clock)
           -> .x0;
      }), (std/num/ddouble/round-to-prec((match (c) {
          ((.skip std/time/date/Clock((.pat01: std/core/types/int) : std/core/types/int, (.pat11: std/core/types/int) : std/core/types/int, ((.skip std/num/ddouble/Ddouble((.pat21: std/core/types/float64) : std/core/types/float64, (.pat31: std/core/types/float64) : std/core/types/float64) : std/num/ddouble/ddouble ) as .x1: std/num/ddouble/ddouble) : std/num/ddouble/ddouble) : clock ) as .pat5: clock)
             -> .x1;
        }), (match (prec) {
          ((std/core/types/Optional((.prec.4735: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat6: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> .prec.4735;
          ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat02: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> 9;
        }))));
  };
fun show0 // inline size: 4
  = fn(i: std/core/types/int, width: (std/core/types/optional :: V -> V)<std/core/types/int>){
    std/core/pad-left((std/core/show(i)), (match (width) {
        ((std/core/types/Optional((.width.5308: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .width.5308;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> 2;
      }), (std/core/types/Optional<std/core/types/char>('0')));
  };
fun show-short // inline size: 4
  = fn(wd: weekday){
    std/core/string.3((std/core/first((std/time/date/show.2(wd)), (std/core/types/Optional<std/core/types/int>(3)))));
  };
fun weekdate // inline size: 2
  = fn(year0: std/core/types/int, month0: std/core/types/int, weekday0: weekday){
    std/time/date/Date(year0, month0, (std/time/date/int(weekday0)));
  };