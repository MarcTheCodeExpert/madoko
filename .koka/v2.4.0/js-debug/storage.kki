// Provide client/server storage
// This module provides file access operations. On the web client, these
// operations only provide accesss to a global object of files which is
// *not* persistent. This code is mainly to ensure we can share as much
// code as possible between client and server.
//
// It also used to resolve includes. i.e., [INCLUDE=/filename].
//
// We keep this sandboxing to eventually use it for the LSP implementation 
module interface storage
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core/hnd = std/core/hnd = "";
import std/core = std/core = "";
import compat/log = compat/log = "";
import compat = compat = "";
import compat/regex = compat/regex = "";
import compat/path = compat/path = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// The `:io` effect is used for functions that perform arbitrary I/O operations.
local alias std/core/io :: E = <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,((std/core/io-noexn :: E) == 3 <(std/core/types/div :: X),((std/core/io-total :: E) == 2 <(std/core/types/ndet :: X),(std/core/console :: X),(std/core/net :: X),(std/core/fsys :: X),(std/core/ui :: X),((std/core/types/st :: H -> E)<(std/core/types/global :: H)> == 1 <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>>)>)>)> = 4;
 
//------------------------------
//#kki: type declarations
 
// A binary buffer
pub value{0,1} type buffer {
  // A binary buffer
  con Buffer(obj: std/core/types/any) : (obj : std/core/types/any) -> buffer;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `obj` constructor field of the `:buffer` type.
fun obj : (^ buffer : buffer) -> std/core/types/any;
pub fun .copy : (.this : buffer, obj : (std/core/types/optional :: V -> V)<std/core/types/any>) -> buffer;
val sandboxed : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/maybe :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>>;
fun xlength : (obj : std/core/types/any) -> std/core/types/int;
val fileChar : std/core/types/string;
val rxPathSep : compat/regex/regex;
// In the browser, removes all files.
pub fun clear : () -> <(std/core/io :: E)> ();
fun xcopyFile : (fnameOld : std/core/types/string, fnameNew : std/core/types/string) -> <(std/core/io :: E)> ();
pub fun cwd : () -> <(std/core/io :: E)> std/core/types/string;
fun xfexistsSync : (fileName : std/core/types/string) -> <(std/core/io :: E)> std/core/types/bool;
fun xmkdirp : (dir : std/core/types/string, mode : (std/core/types/optional :: V -> V)<std/core/types/int>) -> <(std/core/io :: E)> ();
fun xreadBase64FileSync : (fileName : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
fun xreadFileSync : (fileName : std/core/types/string) -> <(std/core/io :: E)> std/core/types/any;
fun xreadInt1 : (obj : std/core/types/any, ofs : std/core/types/int) -> std/core/types/int;
fun xreadInt4 : (obj : std/core/types/any, ofs : std/core/types/int, bigendian : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> std/core/types/int;
fun xreadTextFileSync : (fileName : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
// \\ is not possible for some reason --> commented for now
pub fun relative : (from : std/core/types/string, to : std/core/types/string) -> std/core/types/string;
fun xrename : (fnameOld : std/core/types/string, fnameNew : std/core/types/string) -> <(std/core/io :: E)> ();
fun xtoBase64 : (obj : std/core/types/any) -> std/core/types/string;
fun xwriteTextFileSync : (fileName : std/core/types/string, content : std/core/types/string) -> <(std/core/io :: E)> ();
fun xunlinkSync : (fileName : std/core/types/string) -> <(std/core/io :: E)> ();
fun xwriteBase64FileSync : (fileName : std/core/types/string, content : std/core/types/string) -> <(std/core/io :: E)> ();
pub fun length : (b : buffer) -> std/core/types/int;
val rxRootRelative : compat/regex/regex;
fun under : (path : std/core/types/string, roots : (std/core/list :: V -> V)<std/core/types/string>) -> std/core/types/bool;
pub fun xnormalize : (path : std/core/types/string) -> std/core/types/string;
// monadic lift
fun .mlift2138-checkSandbox : (xpath : std/core/types/string, .c.1986 : ()) -> std/core/types/string;
// monadic lift
fun .mlift2139-checkSandbox : (path : std/core/types/string, roots : (std/core/list :: V -> V)<std/core/types/string>, .y.1984 : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
// monadic lift
fun .mlift2140-checkSandbox : (path : std/core/types/string, .y.1982 : (std/core/types/maybe :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>> std/core/types/string;
pub fun checkSandbox : (path : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
// monadic lift
fun .mlift2141-copyFile : (xfnameOld : std/core/types/string, xfnameNew : std/core/types/string) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2142-copyFile : (fnameNew : std/core/types/string, xfnameOld : std/core/types/string) -> <(std/core/io :: E)> ();
pub fun copyFile : (fnameOld : std/core/types/string, fnameNew : std/core/types/string) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2143-enforceSandbox : (.y.1991 : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
// monadic lift
fun .mlift2144-enforceSandbox : (.y.1992 : (std/core/list :: V -> V)<std/core/types/string>) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>> ();
pub fun enforceSandbox : (roots : (std/core/types/optional :: V -> V)<(std/core/list :: V -> V)<std/core/types/string>>) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2145-fexistsSync : (xfileName : std/core/types/string) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>> std/core/types/bool;
pub fun fexistsSync : (fileName : std/core/types/string) -> <(std/core/io :: E)> std/core/types/bool;
// monadic lift
fun .mlift2146-mkdirp : (mode : (std/core/types/optional :: V -> V)<std/core/types/int>, xdir : std/core/types/string) -> <(std/core/io :: E)> ();
pub fun mkdirp : (dir : std/core/types/string, mode : (std/core/types/optional :: V -> V)<std/core/types/int>) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2147-readBase64FileSync : (xfileName : std/core/types/string, .c.2000 : ()) -> std/core/types/string;
// monadic lift
fun .mlift2148-readBase64FileSync : (fileName : std/core/types/string, required : (std/core/types/optional :: V -> V)<std/core/types/bool>, xfileName : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
// Read a binary file synchronously (using base64 encoding)
pub fun readBase64FileSync : (fileName : std/core/types/string, required : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> <(std/core/io :: E)> std/core/types/string;
// monadic lift
fun .mlift2149-tryReadBase64File : (xfileName : std/core/types/string, .c.2004 : ()) -> std/core/types/string;
// monadic lift
fun .mlift2150-tryReadBase64File : (fileName0 : std/core/types/string, required0 : (std/core/types/optional :: V -> V)<std/core/types/bool>, xfileName : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
// monadic lift
fun .mlift2151-tryReadBase64File : (.y.2006 : std/core/types/string) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>> (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>;
// Try to a binary file synchronously (using base64 encoding)
pub fun tryReadBase64File : (fileName : std/core/types/string, required : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> <(std/core/io :: E)> (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>;
// monadic lift
fun .mlift2152-readBase64FileDef : (def : std/core/types/string, .y.2008 : (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>) -> <(std/core/io :: E)> std/core/types/string;
// Try to read a binary file in base64; return a default value in case of an error.
pub fun readBase64FileDef : (fileName : std/core/types/string, def : std/core/types/string, required : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> <(std/core/io :: E)> std/core/types/string;
// monadic lift
fun .mlift2153-readFileSync : (.y.2010 : std/core/types/any) -> <(std/core/io :: E)> buffer;
// monadic lift
fun .mlift2154-readFileSync : (xfileName : std/core/types/string) -> <(std/core/io :: E)> buffer;
// Read a binary file into a buffer
pub fun readFileSync : (fileName : std/core/types/string) -> <(std/core/io :: E)> buffer;
pub fun readInt1 : (b : buffer, ofs : std/core/types/int) -> std/core/types/int;
pub fun readInt4 : (b : buffer, ofs : std/core/types/int, bigendian : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> std/core/types/int;
// monadic lift
fun .mlift2155-readTextFileSync : (xfileName : std/core/types/string, .c.2013 : ()) -> std/core/types/string;
// monadic lift
fun .mlift2156-readTextFileSync : (fileName : std/core/types/string, required : (std/core/types/optional :: V -> V)<std/core/types/bool>, xfileName : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
// Read a text file synchronously (using UTF8 encoding)
pub fun readTextFileSync : (fileName : std/core/types/string, required : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> <(std/core/io :: E)> std/core/types/string;
// monadic lift
fun .mlift2157-tryReadTextFile : (xfileName : std/core/types/string, .c.2017 : ()) -> std/core/types/string;
// monadic lift
fun .mlift2158-tryReadTextFile : (fileName0 : std/core/types/string, required0 : (std/core/types/optional :: V -> V)<std/core/types/bool>, xfileName : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
// monadic lift
fun .mlift2159-tryReadTextFile : (.y.2019 : std/core/types/string) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>> (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>;
// Try to a text file synchronously (using UTF8 encoding)
pub fun tryReadTextFile : (fileName : std/core/types/string, required : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> <(std/core/io :: E)> (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>;
// monadic lift
fun .mlift2160-readTextFileDef : (def : std/core/types/string, .y.2021 : (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>) -> <(std/core/io :: E)> std/core/types/string;
// Try to read a text file; return a default value in case of an error.
pub fun readTextFileDef : (fileName : std/core/types/string, def : std/core/types/string, required : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> <(std/core/io :: E)> std/core/types/string;
// Read a text file synchronously (using UTF8 encoding) without sandbox restrictions
pub fun readTextFileNoSandbox : (fileName : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
// monadic lift
fun .mlift2161-rename : (xfnameOld : std/core/types/string, xfnameNew : std/core/types/string) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2162-rename : (fnameNew : std/core/types/string, xfnameOld : std/core/types/string) -> <(std/core/io :: E)> ();
pub fun rename : (fnameOld : std/core/types/string, fnameNew : std/core/types/string) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2163-searchFileSync : (f : std/core/types/string, .y.2028 : std/core/types/bool) -> <(std/core/io :: E)> (std/core/types/maybe :: V -> V)<std/core/types/string>;
// monadic lift
fun .mlift2164-searchFileSync : (fnames : (std/core/list :: V -> V)<std/core/types/string>) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>> (std/core/types/maybe :: V -> V)<std/core/types/string>;
// Search for a file along a list of directories
pub fun searchFileSync : (dirs : (std/core/list :: V -> V)<std/core/types/string>, fname : std/core/types/string) -> <(std/core/io :: E)> (std/core/types/maybe :: V -> V)<std/core/types/string>;
pub fun toBase64 : (b : buffer) -> std/core/types/string;
// monadic lift
fun .mlift2165-writeTextFileSync : (content : std/core/types/string, fileName : std/core/types/string, xfileName : std/core/types/string) -> <(std/core/io :: E)> ();
// Write a text file synchronously (using UTF8 encoding)
pub fun writeTextFileSync : (fileName : std/core/types/string, content : std/core/types/string) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2166-tryWriteTextFile : (content0 : std/core/types/string, fileName0 : std/core/types/string, xfileName : std/core/types/string) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2167-tryWriteTextFile : (wild_0 : ()) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>> std/core/types/bool;
// Try to write a text file synchronously (using UTF8 encoding).
// Returns "True" if successful.
pub fun tryWriteTextFile : (fileName : std/core/types/string, content : std/core/types/string) -> <(std/core/io :: E)> std/core/types/bool;
// monadic lift
fun .mlift2168-tryCopyTextFile : (outName : std/core/types/string, .y.2036 : (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>) -> <(std/core/io :: E)> std/core/types/bool;
pub fun tryCopyTextFile : (fileName : std/core/types/string, outName : std/core/types/string, required : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> <(std/core/io :: E)> std/core/types/bool;
// monadic lift
fun .mlift2169-tryCopyTextFileFromTo : (outName.1962 : std/core/types/string, .y.2039 : (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>) -> <(std/core/io :: E)> std/core/types/bool;
pub fun tryCopyTextFileFromTo : (fname : std/core/types/string, srcDir : std/core/types/string, outDir : std/core/types/string, required : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> <(std/core/io :: E)> std/core/types/bool;
// monadic lift
fun .mlift2170-tryReadFileSync : (.y.2043 : std/core/types/any) -> <(std/core/io :: E)> buffer;
// monadic lift
fun .mlift2171-tryReadFileSync : (xfileName : std/core/types/string) -> <(std/core/io :: E)> buffer;
// monadic lift
fun .mlift2172-tryReadFileSync : (.y.2044 : buffer) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>> (std/core/types/maybe :: V -> V)<buffer>;
// try to ead a binary file into a buffer
pub fun tryReadFileSync : (fileName : std/core/types/string) -> <(std/core/io :: E)> (std/core/types/maybe :: V -> V)<buffer>;
// monadic lift
fun .mlift2173-tryRename : (xfnameOld : std/core/types/string, xfnameNew : std/core/types/string) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2174-tryRename : (fnameNew0 : std/core/types/string, xfnameOld : std/core/types/string) -> <(std/core/io :: E)> ();
pub fun tryRename : (fnameOld : std/core/types/string, fnameNew : std/core/types/string) -> <(std/core/io :: E)> ();
pub fun unlinkSync : (fileName : std/core/types/string) -> <(std/core/io :: E)> ();
// Delete a file
pub fun tryUnlinkSync : (fname : std/core/types/string) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2175-writeBase64FileSync : (content : std/core/types/string, fileName : std/core/types/string, xfileName : std/core/types/string) -> <(std/core/io :: E)> ();
// Write a binary file synchronously (using base64 encoding)
pub fun writeBase64FileSync : (fileName : std/core/types/string, content : std/core/types/string) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2176-tryWriteBase64File : (content0 : std/core/types/string, fileName0 : std/core/types/string, xfileName : std/core/types/string) -> <(std/core/io :: E)> ();
// monadic lift
fun .mlift2177-tryWriteBase64File : (wild_0 : ()) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>> std/core/types/bool;
// Try to write a binary file synchronously (using base64 encoding).
// Returns "True" if successful.
pub fun tryWriteBase64File : (fileName : std/core/types/string, content : std/core/types/string) -> <(std/core/io :: E)> std/core/types/bool;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
specialize "_*" fun searchFileSync // inline size: 1
  = fn<(std/core/io :: E)>(dirs: (std/core/list :: V -> V)<std/core/types/string>, fname: std/core/types/string){
    val fnames : (std/core/list :: V -> V)<std/core/types/string>
          = std/core/map.5<std/core/types/string,std/core/types/string,<(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>>>(dirs, (fn<<(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>>>(dir: std/core/types/string){
              (std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>>,(path1 : std/core/types/string, path2 : std/core/types/string) -> std/core/types/string,(path1 : std/core/types/string, path2 : std/core/types/string) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>> std/core/types/string>(compat/path/combine)(dir, fname));
            }));
    compat/foreachUntil<std/core/types/string,std/core/types/string,<(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>>>(fnames, (fn<<(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>>>(f: std/core/types/string){
        (match ((storage/fexistsSync(f))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
             -> std/core/types/Just<std/core/types/string>(f);
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/Nothing<std/core/types/string>;
        });
      }));
  };
specialize "*_" fun under // inline size: 1
  = fn(path: std/core/types/string, roots: (std/core/list :: V -> V)<std/core/types/string>){
    std/core/any<std/core/types/string,(std/core/types/(<>) :: E)>(roots, (fn(root: std/core/types/string){
        (match ((std/core/(==.3)(root, ""))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
             -> compat/regex/contains(path, storage/rxRootRelative, (std/core/types/None<std/core/types/int>));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> (match ((compat/startsWith(path, (std/core/(++.1)(root, "/"))))) {
              ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
                 -> val x.1943 : std/core/types/int
                          = std/core/count.1(root);
                compat/regex/contains((compat/substr(path, (std/core/int-add(x.1943, 1)))), storage/rxRootRelative, (std/core/types/None<std/core/types/int>));
              (.pat2: std/core/types/bool)
                 -> std/core/types/False;
            });
        });
      }));
  };
inline borrow "^" fun obj // inline size: 0
  = fn(buffer: buffer){
    match (buffer) {
      ((.skip storage/Buffer((.x: std/core/types/any) : std/core/types/any) : buffer ) as .pat: buffer)
         -> .x;
    };
  };
fun .copy // inline size: 2
  = fn(.this: buffer, obj0: (std/core/types/optional :: V -> V)<std/core/types/any>){
    storage/Buffer((match (obj0) {
      ((std/core/types/Optional((.obj.114: std/core/types/any) : std/core/types/any) : (std/core/types/optional :: V -> V)<std/core/types/any> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/any>))
         -> .obj.114;
      ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/any> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/any>))
         -> (match (.this) {
          ((.skip storage/Buffer((.x: std/core/types/any) : std/core/types/any) : buffer ) as .pat1: buffer)
             -> .x;
        });
    }));
  };
inline val fileChar // inline size: 0
  = "[^\x5C\x5C\x5C/\x5C?\x5C*\x5C.\x5C|<>&:\x5Cu0000-\x5Cu001F]";
fun length // inline size: 1
  = fn(b: buffer){
    storage/xlength((match (b) {
      ((.skip storage/Buffer((.x: std/core/types/any) : std/core/types/any) : buffer ) as .pat: buffer)
         -> .x;
    }));
  };
fun copyFile // inline size: 3
  = fn<(std/core/io :: E)>(fnameOld: std/core/types/string, fnameNew: std/core/types/string){
    val xfnameOld : std/core/types/string
      = storage/checkSandbox(fnameOld);
    val xfnameNew : std/core/types/string
      = storage/checkSandbox(fnameNew);
    storage/xcopyFile(xfnameOld, xfnameNew);
  };
fun mkdirp // inline size: 4
  = fn<(std/core/io :: E)>(dir: std/core/types/string, mode: (std/core/types/optional :: V -> V)<std/core/types/int>){
    val xdir : std/core/types/string
          = storage/checkSandbox(dir);
    storage/xmkdirp(xdir, (std/core/types/Optional<std/core/types/int>((match (mode) {
        ((std/core/types/Optional((.mode.1333: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .mode.1333;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> 511;
      }))));
  };
fun readBase64FileDef // inline size: 4
  = fn<(std/core/io :: E)>(fileName: std/core/types/string, def: std/core/types/string, required: (std/core/types/optional :: V -> V)<std/core/types/bool>){
    match ((storage/tryReadBase64File(fileName, (std/core/types/Optional<std/core/types/bool>((match (required) {
        ((std/core/types/Optional((.required.1411: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> .required.1411;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> std/core/types/False;
      })))))) {
      ((std/core/types/Left(((.skip std/core/Exception((.pat3: std/core/types/string) : std/core/types/string, (.pat4: std/core/exception-info) : std/core/exception-info) : std/core/exception ) as .pat2: std/core/exception) : std/core/exception) : (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string> ) as .pat1: ((std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>))
         -> def;
      ((.skip std/core/types/Right((content: std/core/types/string) : std/core/types/string) : (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string> ) as .pat5: ((std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>))
         -> content;
    };
  };
fun readFileSync // inline size: 3
  = fn<(std/core/io :: E)>(fileName: std/core/types/string){
    val xfileName : std/core/types/string
          = storage/checkSandbox(fileName);
    storage/Buffer((storage/xreadFileSync(xfileName)));
  };
fun readInt1 // inline size: 1
  = fn(b: buffer, ofs: std/core/types/int){
    storage/xreadInt1((match (b) {
        ((.skip storage/Buffer((.x: std/core/types/any) : std/core/types/any) : buffer ) as .pat: buffer)
           -> .x;
      }), ofs);
  };
fun readInt4 // inline size: 3
  = fn(b: buffer, ofs: std/core/types/int, bigendian: (std/core/types/optional :: V -> V)<std/core/types/bool>){
    storage/xreadInt4((match (b) {
        ((.skip storage/Buffer((.x: std/core/types/any) : std/core/types/any) : buffer ) as .pat: buffer)
           -> .x;
      }), ofs, (std/core/types/Optional<std/core/types/bool>((match (bigendian) {
        ((std/core/types/Optional((.bigendian.1461: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> .bigendian.1461;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat00: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> std/core/types/True;
      }))));
  };
fun readTextFileDef // inline size: 4
  = fn<(std/core/io :: E)>(fileName: std/core/types/string, def: std/core/types/string, required: (std/core/types/optional :: V -> V)<std/core/types/bool>){
    match ((storage/tryReadTextFile(fileName, (std/core/types/Optional<std/core/types/bool>((match (required) {
        ((std/core/types/Optional((.required.1537: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> .required.1537;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> std/core/types/False;
      })))))) {
      ((std/core/types/Left(((.skip std/core/Exception((.pat3: std/core/types/string) : std/core/types/string, (.pat4: std/core/exception-info) : std/core/exception-info) : std/core/exception ) as .pat2: std/core/exception) : std/core/exception) : (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string> ) as .pat1: ((std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>))
         -> def;
      ((.skip std/core/types/Right((content: std/core/types/string) : std/core/types/string) : (std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string> ) as .pat5: ((std/core/types/either :: (V, V) -> V)<std/core/exception,std/core/types/string>))
         -> content;
    };
  };
fun readTextFileNoSandbox // inline size: 2
  = fn<(std/core/io :: E)>(fileName: std/core/types/string){
    storage/xreadTextFileSync((compat/path/normalize(fileName)));
  };
fun rename // inline size: 3
  = fn<(std/core/io :: E)>(fnameOld: std/core/types/string, fnameNew: std/core/types/string){
    val xfnameOld : std/core/types/string
      = storage/checkSandbox(fnameOld);
    val xfnameNew : std/core/types/string
      = storage/checkSandbox(fnameNew);
    storage/xrename(xfnameOld, xfnameNew);
  };
fun toBase64 // inline size: 1
  = fn(b: buffer){
    storage/xtoBase64((match (b) {
      ((.skip storage/Buffer((.x: std/core/types/any) : std/core/types/any) : buffer ) as .pat: buffer)
         -> .x;
    }));
  };
fun writeTextFileSync // inline size: 4
  = fn<(std/core/io :: E)>(fileName: std/core/types/string, content: std/core/types/string){
    val xfileName : std/core/types/string
      = storage/checkSandbox(fileName);
    val _ : ()
      = std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>>,(logName : std/core/types/string, message : std/core/types/string) -> (),(logName : std/core/types/string, message : std/core/types/string) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>> ()>(compat/log/log)("filesWrite", fileName);
    storage/xwriteTextFileSync(xfileName, content);
  };
fun unlinkSync // inline size: 2
  = fn<(std/core/io :: E)>(fileName: std/core/types/string){
    val xfileName : std/core/types/string
          = storage/checkSandbox(fileName);
    storage/xunlinkSync(xfileName);
  };
fun writeBase64FileSync // inline size: 4
  = fn<(std/core/io :: E)>(fileName: std/core/types/string, content: std/core/types/string){
    val xfileName : std/core/types/string
      = storage/checkSandbox(fileName);
    val _ : ()
      = std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>>,(logName : std/core/types/string, message : std/core/types/string) -> (),(logName : std/core/types/string, message : std/core/types/string) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>> ()>(compat/log/log)("filesWrite", fileName);
    storage/xwriteBase64FileSync(xfileName, content);
  };