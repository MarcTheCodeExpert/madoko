// Log messages
module interface v1/std/log
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core/hnd = std/core/hnd = "";
import std/core = std/core = "";
import v1/std/data/dict = v1/std/data/dict = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// The `:io` effect is used for functions that perform arbitrary I/O operations.
local alias std/core/io :: E = <(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,((std/core/io-noexn :: E) == 3 <(std/core/types/div :: X),((std/core/io-total :: E) == 2 <(std/core/types/ndet :: X),(std/core/console :: X),(std/core/net :: X),(std/core/fsys :: X),(std/core/ui :: X),((std/core/types/st :: H -> E)<(std/core/types/global :: H)> == 1 <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>>)>)>)> = 4;
// Stateful functions can manipulate heap `:h` using allocations, reads and writes.
local alias std/core/types/st<(h :: H)> :: H -> E = <(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/write :: H -> X)<(h :: H)>,(std/core/types/alloc :: H -> X)<(h :: H)>> = 1;
 
//------------------------------
//#kki: type declarations
 
 
//------------------------------
//#kki: declarations
 
val log-dict : (v1/std/data/dict/mdict :: (H, V) -> V)<(std/core/types/global :: H),std/core/types/string>;
// Get the current log. Since this is in the `io` effect, `with-log` is preferred.
pub fun get-log : (log-name : std/core/types/string) -> <(std/core/io :: E)> std/core/types/string;
// Total fun that logs a message in a certain log `log-name`.
// Has no observable effect but see `withLog`.
pub fun log : (log-name : std/core/types/string, message : std/core/types/string) -> ();
// Log an error (to log `"error"`). This should be used in particular
// to log errors in pure functions that are otherwise ignored.
pub fun log-error : (message : std/core/types/string) -> ();
// Log a warning (to log `"warning"`). This should be used in particular
// to log warnings in pure functions that are otherwise ignored.
pub fun log-warning : (message : std/core/types/string) -> ();
// Disable logging completely.
pub fun nolog : () -> <(std/core/types/st :: H -> E)<(std/core/types/global :: H)>> ();
// monadic lift
fun .mlift963-with-log : forall<a> (l : std/core/types/string, x : a, .c.958 : ()) -> (std/core/types/string, a);
// Encloses a possibly total `action` and returns its result together
// with the contents of a log named `log-name`. The contents of the log
// are non-deterministically determined. However, in practice, they contain
// any messages that were recorded in the `action` by calls to `log`.
// However, if `nolog` was called, the log is always empty.
pub fun with-log : forall<a,(e :: E)> (log-name : std/core/types/string, action : () -> <(std/core/types/ndet :: X)|(e :: E)> a) -> <(std/core/types/ndet :: X)|(e :: E)> (std/core/types/string, a);
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
fun get-log // inline size: 4
  = fn<(std/core/io :: E)>(log-name: std/core/types/string){
    std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>>,(m : (std/core/types/maybe :: V -> V)<std/core/types/string>, nothing : std/core/types/string) -> std/core/types/string,(m : (std/core/types/maybe :: V -> V)<std/core/types/string>, nothing : std/core/types/string) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>> std/core/types/string>((std/core/maybe.1<std/core/types/string>))((std/core/types/.open<<(std/core/types/read :: H -> X)<(std/core/types/global :: H)>>,<(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>>,(md : (v1/std/data/dict/mdict :: (H, V) -> V)<(std/core/types/global :: H),std/core/types/string>, s : std/core/types/string) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>> (std/core/types/maybe :: V -> V)<std/core/types/string>,(md : (v1/std/data/dict/mdict :: (H, V) -> V)<(std/core/types/global :: H),std/core/types/string>, s : std/core/types/string) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/console :: X),(std/core/types/div :: X),(std/core/types/handled :: HX -> X)<(std/core/exn :: HX)>,(std/core/fsys :: X),(std/core/types/ndet :: X),(std/core/net :: X),(std/core/ui :: X),(std/core/types/write :: H -> X)<(std/core/types/global :: H)>> (std/core/types/maybe :: V -> V)<std/core/types/string>>((v1/std/data/dict/([])<std/core/types/string,(std/core/types/global :: H)>))(v1/std/log/log-dict, log-name)), "");
  };
fun log-error // inline size: 1
  = fn(message: std/core/types/string){
    v1/std/log/log("error", message);
  };
fun log-warning // inline size: 1
  = fn(message: std/core/types/string){
    v1/std/log/log("warning", message);
  };
fun nolog // inline size: 1
  = fn<(std/core/types/st :: H -> E)<(std/core/types/global :: H)>>(){
    v1/std/data/dict/([].1)<std/core/types/string,(std/core/types/global :: H)>(v1/std/log/log-dict, "nolog", "");
  };